# 滚动公告组件智能暂停与恢复实现方案

## 完整实现代码

```javascript
class ScrollNotice {
  constructor(container, options = {}) {
    this.container = typeof container === 'string' 
      ? document.querySelector(container) 
      : container;
    this.speed = options.speed || 50; // 像素/秒
    this.delay = options.delay || 3000; // 停留时间(ms)
    this.direction = options.direction || 'left'; // left/right/up/down
    this.content = options.content || this.container.innerHTML;
    
    this.isHovering = false;
    this.pausedTime = 0;
    this.animationId = null;
    this.startTime = 0;
    this.remainingDelay = 0;
    
    this.init();
  }
  
  init() {
    this.container.innerHTML = '';
    this.container.style.overflow = 'hidden';
    this.container.style.position = 'relative';
    
    this.notice = document.createElement('div');
    this.notice.style.position = 'absolute';
    this.notice.style.whiteSpace = 'nowrap';
    this.notice.innerHTML = this.content;
    this.container.appendChild(this.notice);
    
    this.setupEvents();
    this.startAnimation();
  }
  
  setupEvents() {
    this.container.addEventListener('mouseenter', () => {
      this.pauseAnimation();
    });
    
    this.container.addEventListener('mouseleave', () => {
      this.resumeAnimation();
    });
  }
  
  startAnimation() {
    this.resetPosition();
    this.startTime = performance.now();
    this.animate();
  }
  
  animate() {
    if (this.isHovering) {
      this.animationId = null;
      return;
    }
    
    const now = performance.now();
    const elapsed = now - this.startTime - this.pausedTime;
    
    // 处理停留阶段
    if (this.remainingDelay > 0) {
      this.remainingDelay -= now - this.lastFrameTime;
      if (this.remainingDelay <= 0) {
        this.resetPosition();
        this.startTime = performance.now();
        this.pausedTime = 0;
      }
    } 
    // 处理滚动阶段
    else {
      const progress = elapsed / 1000 * this.speed;
      
      switch (this.direction) {
        case 'left':
          this.notice.style.transform = `translateX(-${progress}px)`;
          break;
        case 'right':
          this.notice.style.transform = `translateX(${progress}px)`;
          break;
        case 'up':
          this.notice.style.transform = `translateY(-${progress}px)`;
          break;
        case 'down':
          this.notice.style.transform = `translateY(${progress}px)`;
          break;
      }
      
      // 检查是否滚动完毕
      const containerRect = this.container.getBoundingClientRect();
      const noticeRect = this.notice.getBoundingClientRect();
      
      let isFinished = false;
      switch (this.direction) {
        case 'left':
          isFinished = noticeRect.right <= containerRect.left;
          break;
        case 'right':
          isFinished = noticeRect.left >= containerRect.right;
          break;
        case 'up':
          isFinished = noticeRect.bottom <= containerRect.top;
          break;
        case 'down':
          isFinished = noticeRect.top >= containerRect.bottom;
          break;
      }
      
      if (isFinished) {
        this.remainingDelay = this.delay;
      }
    }
    
    this.lastFrameTime = now;
    this.animationId = requestAnimationFrame(() => this.animate());
  }
  
  pauseAnimation() {
    if (!this.isHovering) {
      this.isHovering = true;
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
        this.animationId = null;
      }
      // 记录暂停时的剩余延迟时间
      if (this.remainingDelay > 0) {
        this.savedDelay = this.remainingDelay;
      }
    }
  }
  
  resumeAnimation() {
    if (this.isHovering) {
      this.isHovering = false;
      // 恢复剩余延迟时间
      if (this.savedDelay) {
        this.remainingDelay = this.savedDelay;
        this.savedDelay = 0;
      }
      this.pausedTime += performance.now() - this.lastFrameTime;
      this.startTime = performance.now();
      this.animate();
    }
  }
  
  resetPosition() {
    switch (this.direction) {
      case 'left':
        this.notice.style.transform = `translateX(${this.container.offsetWidth}px)`;
        break;
      case 'right':
        this.notice.style.transform = `translateX(-${this.notice.offsetWidth}px)`;
        break;
      case 'up':
        this.notice.style.transform = `translateY(${this.container.offsetHeight}px)`;
        break;
      case 'down':
        this.notice.style.transform = `translateY(-${this.notice.offsetHeight}px)`;
        break;
    }
  }
  
  destroy() {
    this.container.removeEventListener('mouseenter', this.pauseAnimation);
    this.container.removeEventListener('mouseleave', this.resumeAnimation);
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }
  }
}
```

## 核心实现原理

### 1. 动画控制机制

- **requestAnimationFrame**：使用浏览器原生动画API实现平滑滚动
- **性能计时**：通过 `performance.now()` 精确计算动画时间
- **状态管理**：维护 `isHovering` 状态标志控制播放/暂停

### 2. 暂停/恢复逻辑

```javascript
pauseAnimation() {
  // 记录当前滚动位置和剩余时间
  this.pauseTime = Date.now();
  this.pauseScrollPosition = this.getCurrentScrollPosition();
  cancelAnimationFrame(this.animationId);
}

resumeAnimation() {
  // 计算已暂停时长
  const pausedDuration = Date.now() - this.pauseTime;
  
  // 调整下次动画开始时间
  this.startTime += pausedDuration;
  
  // 恢复动画
  this.animate();
}
```

### 3. 剩余时间处理

```javascript
// 在动画循环中
const elapsed = now - this.startTime - this.pausedTime;

if (this.remainingDelay > 0) {
  // 处理停留等待时间
  this.remainingDelay -= deltaTime;
  if (this.remainingDelay <= 0) {
    this.resetAnimation();
  }
} else {
  // 正常滚动逻辑
  this.updateScrollPosition(elapsed);
}
```

## 使用示例

### HTML 结构
```html
<div id="noticeContainer" style="width: 300px; height: 30px; border: 1px solid #ccc;"></div>
```

### JavaScript 初始化
```javascript
const notice = new ScrollNotice('#noticeContainer', {
  content: '重要公告：本系统将于今晚00:00至02:00进行维护升级',
  speed: 60,       // 滚动速度(像素/秒)
  delay: 2000,      // 每次滚动结束后的停留时间(ms)
  direction: 'left' // 滚动方向
});
```

## 高级功能扩展

### 1. 触摸设备支持
```javascript
setupEvents() {
  this.container.addEventListener('mouseenter', this.pauseAnimation);
  this.container.addEventListener('mouseleave', this.resumeAnimation);
  // 添加触摸事件
  this.container.addEventListener('touchstart', this.pauseAnimation);
  this.container.addEventListener('touchend', this.resumeAnimation);
}
```

### 2. 多内容轮播
```javascript
constructor(container, options) {
  // ...
  this.notices = options.notices || []; // 多个公告内容
  this.currentIndex = 0;
}

showNextNotice() {
  this.currentIndex = (this.currentIndex + 1) % this.notices.length;
  this.notice.innerHTML = this.notices[this.currentIndex];
  this.resetPosition();
}
```

### 3. 响应式调整
```javascript
handleResize() {
  this.resetPosition();
  if (!this.isHovering) {
    this.startAnimation();
  }
}

// 初始化时添加
window.addEventListener('resize', this.handleResize.bind(this));
```

## 性能优化建议

1. **节流处理**：对 `mousemove` 事件进行节流
2. **离屏暂停**：当页面不可见时自动暂停
```javascript
document.addEventListener('visibilitychange', () => {
  if (document.hidden) this.pauseAnimation();
  else this.resumeAnimation();
});
```
3. **GPU加速**：使用 `transform` 代替 `left/top` 属性
4. **内存管理**：组件销毁时正确移除事件监听

## 浏览器兼容性

- 现代浏览器全面支持
- 如需支持IE11，需添加 `requestAnimationFrame` polyfill
```javascript
window.requestAnimationFrame = window.requestAnimationFrame || 
  function(callback) {
    return setTimeout(callback, 16);
  };
```

## 总结

这个滚动公告组件实现了：

1. **智能暂停/恢复**：精确记录剩余时间，恢复后继续播放
2. **多方向支持**：支持左/右/上/下四个滚动方向
3. **流畅动画**：基于 `requestAnimationFrame` 的高性能实现
4. **易扩展性**：可轻松添加多内容轮播等高级功能

关键点在于通过精确的时间计算和状态管理，确保用户体验的连贯性，特别是在处理暂停后继续播放剩余时间的功能上。
