---
tags: ['ref()', 'computed()', 'reactive()','readonly()','watchEffect()','watchPostEffect()','watchSyncEffect()', 'watch()','onWatcherCleanup()']
---

# 响应式: 核心

## ref() 详解

作为 Vue 响应式系统的核心 API 之一，`ref` 是构建响应式数据的基础工具。让我们深入探讨它的用法和原理。

### 1. ref 的基本概念

`ref` 用于创建一个响应式的引用对象，它接受一个内部值并返回一个响应式的、可变的 ref 对象。这个对象有一个指向内部值的属性 `.value`。

```javascript
import { ref } from 'vue'

const count = ref(0)
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

### 2. ref 的核心参数

`ref` 函数接受一个参数：

1. **初始值**：可以是任意类型（基本类型、对象、数组等）

```javascript
const num = ref(0) // 数字
const str = ref('hello') // 字符串
const obj = ref({ name: 'Vue' }) // 对象
const arr = ref([1, 2, 3]) // 数组
```

### 3. ref 的响应式原理

ref 的实现原理可以简单理解为：

- 对于基本类型：Vue 使用对象的 getter/setter 实现响应式
- 对于引用类型：内部会调用 `reactive` 进行深层响应式转换

```javascript
// 伪代码展示 ref 实现原理
function myRef(value) {
  return {
    get value() {
      track() // 依赖收集
      return value
    },
    set value(newVal) {
      value = newVal
      trigger() // 触发更新
    }
  }
}
```

### 4. 模板中的 ref 使用

在模板中，ref 会自动解包，无需使用 `.value`：

```vue
<template>
  <div>
    <p>Count: {{ count }}</p>
    <button @click="increment">Increment</button>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
  count.value++
}
</script>
```

### 5. ref 与 reactive 的区别

| 特性     | ref           | reactive        |
| -------- | ------------- | --------------- |
| 创建方式 | `ref(value)`  | `reactive(obj)` |
| 访问值   | 需要 `.value` | 直接访问        |
| 适用类型 | 所有类型      | 仅对象/数组     |
| 模板解包 | 自动解包      | 无需解包        |

### 6. ref 的高级用法

#### 6.1 DOM 引用

ref 也可以用于获取 DOM 元素：

```vue
<template>
  <input ref="inputRef" />
</template>

<script setup>
import { ref, onMounted } from 'vue'

const inputRef = ref(null)

onMounted(() => {
  inputRef.value.focus()
})
</script>
```

#### 6.2 组件引用

ref 可以引用子组件实例：

```vue
<template>
  <ChildComponent ref="child" />
</template>

<script setup>
import { ref, onMounted } from 'vue'
import ChildComponent from './ChildComponent.vue'

const child = ref(null)

onMounted(() => {
  console.log(child.value) // 子组件实例
})
</script>
```

### 7. 可运行完整示例

下面是一个完整的 Vue 组件示例，展示了 ref 的各种用法：

```vue
<template>
  <div class="ref-demo">
    <h2>Ref Demo</h2>
    
    <!-- 基本类型 -->
    <div class="section">
      <h3>基本类型</h3>
      <p>计数器: {{ counter }}</p>
      <button @click="increment">增加</button>
    </div>
    
    <!-- 引用类型 -->
    <div class="section">
      <h3>引用类型</h3>
      <p>用户信息: {{ user.name }} - {{ user.age }}</p>
      <button @click="updateUser">更新用户</button>
    </div>
    
    <!-- DOM 引用 -->
    <div class="section">
      <h3>DOM 引用</h3>
      <input ref="inputEl" placeholder="将自动获取焦点" />
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'

// 基本类型 ref
const counter = ref(0)
function increment() {
  counter.value++
}

// 引用类型 ref
const user = ref({
  name: '张三',
  age: 25
})
function updateUser() {
  user.value.age++
}

// DOM 引用
const inputEl = ref(null)
onMounted(() => {
  inputEl.value.focus()
})
</script>

<style>
.ref-demo {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}
.section {
  margin-bottom: 20px;
  padding: 15px;
  border: 1px solid #eee;
  border-radius: 5px;
}
button {
  padding: 5px 10px;
  margin-right: 10px;
  cursor: pointer;
}
input {
  padding: 5px;
  width: 200px;
}
</style>
```

### 8. 总结

ref 是 Vue 响应式系统的基石之一，它的核心特点可以概括为：

1. **万能响应式**：可以包装任何类型的值成为响应式对象
2. **值访问**：通过 `.value` 访问/修改内部值
3. **模板便利**：在模板中自动解包，无需 `.value`
4. **引用能力**：不仅可以管理数据，还能引用 DOM 和组件实例

记住这个简单的口诀：**"基本类型要 ref，模板使用不加 value，脚本操作要 value，引用元素也能行"**。

ref 的设计体现了 Vue 的实用主义哲学，它通过简单的 API 解决了复杂的问题，让开发者可以更专注于业务逻辑而非框架细节。

## computed() 详解

作为 Vue 响应式系统的核心 API 之一，`computed()` 提供了声明式计算属性的能力，让我们能够高效地处理派生状态。

### 1. computed 的基本概念

`computed()` 用于创建计算属性，它会根据依赖的响应式数据自动计算并缓存结果，只有当依赖发生变化时才会重新计算。

```javascript
import { ref, computed } from 'vue'

const count = ref(0)
const doubleCount = computed(() => count.value * 2)
```

### 2. computed 的核心参数

`computed()` 接受两种形式的参数：

1. **Getter 函数**：只读计算属性
2. **带有 get 和 set 的对象**：可写计算属性

#### 2.1 Getter 函数形式

```javascript
const double = computed(() => count.value * 2)
```

#### 2.2 Getter/Setter 对象形式

```javascript
const fullName = computed({
  get() {
    return `${firstName.value} ${lastName.value}`
  },
  set(newValue) {
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
```

### 3. computed 的响应式原理

计算属性的核心特性：

- **惰性求值**：只有访问时才会计算
- **缓存机制**：依赖不变时直接返回缓存值
- **依赖追踪**：自动追踪响应式依赖

```javascript
// 伪代码展示 computed 实现原理
function myComputed(getter) {
  let value
  let dirty = true
  
  effect(() => {
    if (dirty) {
      value = getter()
      dirty = false
    }
  })
  
  return {
    get value() {
      return value
    }
  }
}
```

### 4. 模板中的 computed 使用

计算属性在模板中像普通属性一样使用：

```vue
<template>
  <div>
    <p>原始值: {{ count }}</p>
    <p>计算值: {{ doubleCount }}</p>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const count = ref(0)
const doubleCount = computed(() => count.value * 2)
</script>
```

### 5. computed 与方法的区别

| 特性       | computed | method            |
| ---------- | -------- | ----------------- |
| 调用方式   | 属性访问 | 函数调用          |
| 缓存       | 有缓存   | 无缓存            |
| 适用场景   | 派生状态 | 事件处理/业务逻辑 |
| 响应式依赖 | 自动追踪 | 需要手动处理      |

### 6. computed 的高级用法

#### 6.1 依赖多个数据源

```javascript
const total = computed(() => price.value * quantity.value + tax.value)
```

#### 6.2 复杂对象计算

```javascript
const userInfo = computed(() => ({
  name: `${firstName.value} ${lastName.value}`,
  age: currentYear.value - birthYear.value
}))
```

#### 6.3 与其他响应式 API 结合

```javascript
const filteredList = computed(() => 
  list.value.filter(item => item.status === activeStatus.value)
)
```

### 7. 可运行完整示例

下面是一个完整的 Vue 组件示例，展示了 computed 的各种用法：

```vue
<template>
  <div class="computed-demo">
    <h2>Computed Demo</h2>
    
    <!-- 基础计算属性 -->
    <div class="section">
      <h3>基础计算</h3>
      <p>价格: {{ price }} × 数量: {{ quantity }} = 总价: {{ total }}</p>
      <button @click="quantity++">增加数量</button>
    </div>
    
    <!-- 可写计算属性 -->
    <div class="section">
      <h3>可写计算属性</h3>
      <p>全名: <input v-model="fullName" /></p>
      <p>姓: {{ firstName }}, 名: {{ lastName }}</p>
    </div>
    
    <!-- 复杂计算 -->
    <div class="section">
      <h3>复杂计算</h3>
      <p>购物车总价: {{ cartTotal }}</p>
      <p>折扣后价格: {{ discountedPrice }}</p>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

// 基础计算属性
const price = ref(10)
const quantity = ref(1)
const total = computed(() => price.value * quantity.value)

// 可写计算属性
const firstName = ref('张')
const lastName = ref('三')
const fullName = computed({
  get() {
    return `${firstName.value} ${lastName.value}`
  },
  set(newValue) {
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})

// 复杂计算
const cartItems = ref([
  { name: '商品A', price: 100, quantity: 2 },
  { name: '商品B', price: 200, quantity: 1 }
])
const discount = ref(0.9)

const cartTotal = computed(() => 
  cartItems.value.reduce((sum, item) => sum + item.price * item.quantity, 0)
)

const discountedPrice = computed(() => 
  cartTotal.value * discount.value
)
</script>

<style>
.computed-demo {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}
.section {
  margin-bottom: 20px;
  padding: 15px;
  border: 1px solid #eee;
  border-radius: 5px;
}
button {
  padding: 5px 10px;
  margin-right: 10px;
  cursor: pointer;
}
input {
  padding: 5px;
  width: 200px;
}
</style>
```

### 8. 总结

computed 是 Vue 响应式系统中处理派生状态的最佳工具，它的核心优势可以概括为：

1. **声明式编程**：只需描述"是什么"，不用关心"怎么计算"
2. **高效缓存**：自动缓存计算结果，避免重复计算
3. **响应式依赖**：自动追踪依赖关系，精确更新
4. **代码组织**：将复杂逻辑封装为可读性高的计算属性

记住这个简单的口诀：**"派生状态用 computed，自动缓存效率高，依赖追踪不用愁，代码整洁易维护"**。

计算属性的设计体现了 Vue 的响应式哲学，它通过声明式的方式将复杂的状态派生逻辑变得简单直观，是构建可维护 Vue 应用的重要工具。在实际开发中，当遇到需要基于现有状态计算新值的场景时，优先考虑使用 computed 而不是 methods 或 watch，这将带来更好的性能和代码可读性。

## reactive() 深度解析

作为 Vue 3 响应式系统的核心 API，`reactive()` 为复杂数据结构提供了深层次的响应式转换能力。让我们全面剖析这个强大的工具。

### 1. reactive 的基本概念

`reactive()` 接收一个普通对象并返回该对象的响应式代理，所有嵌套属性都会变为响应式的：

```javascript
import { reactive } from 'vue'

const state = reactive({
  count: 0,
  user: {
    name: 'Alice',
    age: 25
  }
})
```

### 2. reactive 的核心参数

`reactive()` 只接受一个参数：

1. **普通对象**：可以是任意层级的对象或数组

```javascript
// 对象
const obj = reactive({ a: 1, b: { c: 2 } })

// 数组
const arr = reactive([1, 2, { name: 'test' }])
```

### 3. reactive 的响应式原理

reactive 基于 ES6 Proxy 实现：

- 创建原始对象的 Proxy 代理
- 拦截所有访问和修改操作
- 自动追踪依赖和触发更新

```javascript
// 伪代码展示 reactive 实现原理
function myReactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key) // 依赖收集
      return Reflect.get(target, key)
    },
    set(target, key, value) {
      Reflect.set(target, key, value)
      trigger(target, key) // 触发更新
      return true
    }
  })
}
```

### 4. 模板中的 reactive 使用

在模板中可以直接访问响应式对象的属性：

```vue
<template>
  <div>
    <p>Count: {{ state.count }}</p>
    <p>User: {{ state.user.name }} - {{ state.user.age }}</p>
  </div>
</template>

<script setup>
import { reactive } from 'vue'

const state = reactive({
  count: 0,
  user: {
    name: 'Alice',
    age: 25
  }
})
</script>
```

### 5. reactive 与 ref 的区别

| 特性     | reactive        | ref           |
| -------- | --------------- | ------------- |
| 创建方式 | `reactive(obj)` | `ref(value)`  |
| 访问值   | 直接访问        | 需要 `.value` |
| 适用类型 | 对象/数组       | 所有类型      |
| 模板使用 | 直接访问        | 自动解包      |
| 重新赋值 | 失去响应性      | 保持响应性    |

### 6. reactive 的高级用法

#### 6.1 深层响应式

reactive 会递归转换所有嵌套属性：

```javascript
const deepObj = reactive({
  level1: {
    level2: {
      level3: 'value'
    }
  }
})
```

#### 6.2 数组处理

reactive 能正确处理数组操作：

```javascript
const list = reactive([1, 2, 3])
list.push(4) // 响应式更新
```

#### 6.3 与 toRefs 配合使用

解构 reactive 对象会失去响应性，使用 toRefs 解决：

```javascript
import { reactive, toRefs } from 'vue'

const state = reactive({ x: 1, y: 2 })
const { x, y } = toRefs(state) // 保持响应性
```

### 7. 可运行完整示例

```vue
<template>
  <div class="reactive-demo">
    <h2>Reactive Demo</h2>
    
    <!-- 基础对象 -->
    <div class="section">
      <h3>基础对象</h3>
      <p>计数器: {{ state.count }}</p>
      <button @click="state.count++">增加</button>
    </div>
    
    <!-- 嵌套对象 -->
    <div class="section">
      <h3>嵌套对象</h3>
      <p>用户信息: {{ state.user.name }} - {{ state.user.age }}</p>
      <button @click="updateUser">更新用户</button>
    </div>
    
    <!-- 数组操作 -->
    <div class="section">
      <h3>数组操作</h3>
      <ul>
        <li v-for="(item, index) in state.items" :key="index">
          {{ item }}
          <button @click="removeItem(index)">删除</button>
        </li>
      </ul>
      <input v-model="newItem" @keyup.enter="addItem" placeholder="添加新项目">
    </div>
    
    <!-- 解构处理 -->
    <div class="section">
      <h3>解构处理</h3>
      <p>坐标: X={{ x }}, Y={{ y }}</p>
      <button @click="x++">增加X</button>
      <button @click="y++">增加Y</button>
    </div>
  </div>
</template>

<script setup>
import { reactive, toRefs } from 'vue'

// 基础响应式对象
const state = reactive({
  count: 0,
  user: {
    name: '张三',
    age: 25
  },
  items: ['苹果', '香蕉', '橙子']
})

// 更新嵌套对象
function updateUser() {
  state.user.age++
}

// 数组操作
const newItem = ref('')
function addItem() {
  if (newItem.value.trim()) {
    state.items.push(newItem.value.trim())
    newItem.value = ''
  }
}
function removeItem(index) {
  state.items.splice(index, 1)
}

// 解构处理
const { x, y } = toRefs(reactive({ x: 10, y: 20 }))
</script>

<style>
.reactive-demo {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}
.section {
  margin-bottom: 20px;
  padding: 15px;
  border: 1px solid #eee;
  border-radius: 5px;
}
button {
  padding: 5px 10px;
  margin: 5px;
  cursor: pointer;
}
input {
  padding: 5px;
  width: 200px;
}
ul {
  padding-left: 20px;
}
li {
  margin: 5px 0;
}
</style>
```

### 8. 总结

reactive 是处理复杂响应式状态的首选方案，其核心特性可归纳为：

1. **深度响应**：自动转换对象所有层级属性
2. **代理透明**：保持原始对象操作方式不变
3. **类型友好**：完美支持对象和数组操作
4. **性能优化**：基于 Proxy 的高效实现

记住这个简单的口诀：**"复杂对象用 reactive，深层响应无遗漏，数组操作也支持，解构记得 toRefs"**。

reactive 的设计体现了 Vue 3 响应式系统的先进性，它通过 ES6 Proxy 实现了比 Vue 2 更强大、更高效的响应式机制。在实际开发中，当需要管理复杂的状态对象时，reactive 是最自然的选择，它能保持代码的直观性同时提供完全的响应式能力。

特别提示：避免直接替换 reactive 对象（如 `state = newState`），这会破坏响应式连接。如需重置状态，可以遍历修改属性或使用 Object.assign：`Object.assign(state, newState)`。

## readonly() 深度解析

`readonly()` 是 Vue 响应式系统中用于创建只读代理的重要 API，它在状态管理和组件通信中扮演着关键角色。

### 1. readonly 的基本概念

`readonly()` 接收一个响应式对象或普通对象，返回该对象的只读代理。所有嵌套属性都会变为只读的：

```javascript
import { reactive, readonly } from 'vue'

const original = reactive({ count: 0 })
const copy = readonly(original)
copy.count++ // 警告：无法修改只读属性
```

### 2. readonly 的核心参数

`readonly()` 接受一个参数：

1. **响应式对象或普通对象**：可以是 reactive、ref 或普通对象

```javascript
// 包装 reactive 对象
const roReactive = readonly(reactive({ a: 1 }))

// 包装 ref 对象
const roRef = readonly(ref(0))

// 包装普通对象
const roPlain = readonly({ b: 2 })
```

### 3. readonly 的实现原理

readonly 同样基于 Proxy 实现，但只提供 getter 拦截：

```javascript
// 伪代码展示 readonly 实现原理
function myReadonly(obj) {
  return new Proxy(obj, {
    get(target, key) {
      return Reflect.get(target, key)
    },
    set() {
      console.warn('Set operation on readonly object')
      return true
    },
    deleteProperty() {
      console.warn('Delete operation on readonly object')
      return true
    }
  })
}
```

### 4. readonly 的典型使用场景

#### 4.1 防止组件意外修改 props

```vue
<script setup>
const props = defineProps({
  user: Object
})

const safeUser = readonly(props.user)
</script>
```

#### 4.2 保护全局状态

```javascript
// store.js
const globalState = reactive({ theme: 'dark' })
export const readonlyState = readonly(globalState)
```

#### 4.3 安全传递响应式数据

```javascript
const state = reactive({ sensitive: true })
provide('safe-data', readonly(state))
```

### 5. 可运行完整示例

```vue
<template>
  <div class="readonly-demo">
    <h2>Readonly Demo</h2>
    
    <!-- 基础只读对象 -->
    <div class="section">
      <h3>基础只读对象</h3>
      <p>计数器: {{ roState.count }}</p>
      <button @click="tryModifyRo">尝试修改只读对象</button>
    </div>
    
    <!-- 嵌套只读对象 -->
    <div class="section">
      <h3>嵌套只读对象</h3>
      <p>用户信息: {{ roUser.name }} - {{ roUser.age }}</p>
      <button @click="tryModifyNested">尝试修改嵌套属性</button>
    </div>
    
    <!-- 与子组件通信 -->
    <div class="section">
      <h3>组件通信保护</h3>
      <ChildComponent :user="roUser" />
    </div>
    
    <!-- 原始对象修改影响 -->
    <div class="section">
      <h3>原始对象修改</h3>
      <p>原始值: {{ original.count }}</p>
      <p>只读副本: {{ roState.count }}</p>
      <button @click="original.count++">修改原始对象</button>
    </div>
  </div>
</template>

<script setup>
import { reactive, readonly, ref } from 'vue'
import ChildComponent from './ChildComponent.vue'

// 基础只读对象
const original = reactive({ count: 0 })
const roState = readonly(original)

function tryModifyRo() {
  try {
    roState.count++
  } catch (e) {
    alert(`操作失败: ${e.message}`)
  }
}

// 嵌套只读对象
const user = reactive({
  name: '张三',
  age: 25,
  address: {
    city: '北京'
  }
})
const roUser = readonly(user)

function tryModifyNested() {
  try {
    roUser.age++
    roUser.address.city = '上海'
  } catch (e) {
    alert(`嵌套修改失败: ${e.message}`)
  }
}
</script>

<style>
.readonly-demo {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}
.section {
  margin-bottom: 20px;
  padding: 15px;
  border: 1px solid #eee;
  border-radius: 5px;
}
button {
  padding: 5px 10px;
  margin: 5px;
  cursor: pointer;
}
</style>
```

### 6. readonly 的注意事项

1. **深度只读**：所有嵌套属性都是只读的
2. **响应式连接**：原始对象修改会影响 readonly 副本
3. **开发警告**：在开发模式下会收到明确的警告信息
4. **性能影响**：生产环境会移除警告，性能影响极小

### 7. 总结

readonly 是 Vue 响应式系统中重要的安全机制，其核心价值可归纳为：

1. **状态保护**：防止意外修改关键数据
2. **明确意图**：通过类型声明表达设计意图
3. **安全共享**：安全地在组件间共享状态
4. **调试辅助**：开发环境提供明确警告

记住这个简单的口诀：**"关键数据要保护，readonly 来帮助，意外修改有警告，安全共享没烦恼"**。

readonly 的设计体现了 Vue 对开发者体验的重视，它通过运行时保护机制，帮助开发者在早期发现潜在的状态管理问题。在实际项目中，合理使用 readonly 可以显著提高代码的健壮性和可维护性，特别是在大型应用和团队协作场景中。

特别提示：readonly 创建的代理是浅只读的，即虽然不能修改属性值，但如果属性值是对象，仍然可以修改这个对象的属性（除非这个对象本身也是 readonly 的）。要实现完全不可变的数据结构，可以考虑与深冻结（deep freeze）结合使用。

## watchEffect() 深度解析

`watchEffect()` 是 Vue 3 响应式系统中用于自动追踪依赖并执行副作用的核心 API，它提供了一种声明式的响应式编程方式。

### 1. watchEffect 的基本概念

`watchEffect()` 会立即执行传入的函数，并响应式追踪其依赖，当依赖变更时重新执行该函数。

```javascript
import { ref, watchEffect } from 'vue'

const count = ref(0)

watchEffect(() => {
  console.log(`count is: ${count.value}`)
})
```

### 2. watchEffect 的核心参数

`watchEffect()` 接受两个参数：

1. **effect 函数**：包含副作用的函数
2. **options 对象（可选）**：配置选项

#### 2.1 effect 函数参数

```javascript
watchEffect((onInvalidate) => {
  // 副作用逻辑
  onInvalidate(() => {
    // 清理逻辑
  })
})
```

#### 2.2 options 对象

```javascript
watchEffect(() => {...}, {
  flush: 'post', // 'pre' | 'post' | 'sync'
  onTrack(e) { /* 调试用 */ },
  onTrigger(e) { /* 调试用 */ }
})
```

### 3. watchEffect 的工作原理

watchEffect 的核心机制：

1. **立即执行**：初始化时立即运行一次
2. **依赖收集**：自动追踪函数内访问的响应式属性
3. **重新执行**：当依赖变化时重新运行
4. **清理机制**：提供 onInvalidate 回调处理清理逻辑

```javascript
// 伪代码展示 watchEffect 实现原理
function myWatchEffect(effect) {
  let cleanup
  
  function wrappedEffect() {
    cleanup?.()
    effect((fn) => { cleanup = fn })
  }
  
  wrappedEffect() // 立即执行
  watch(wrappedEffect) // 依赖变化时重新执行
}
```

### 4. watchEffect 的典型使用场景

#### 4.1 DOM 操作副作用

```javascript
watchEffect(() => {
  document.title = `Count: ${count.value}`
})
```

#### 4.2 异步操作处理

```javascript
watchEffect(async (onInvalidate) => {
  const data = await fetchData(count.value)
  
  onInvalidate(() => {
    // 取消未完成的请求
  })
})
```

#### 4.3 多依赖响应

```javascript
watchEffect(() => {
  console.log(`Count: ${count.value}, User: ${user.name}`)
})
```

### 5. watchEffect 与 watch 的区别

| 特性     | watchEffect        | watch              |
| -------- | ------------------ | ------------------ |
| 依赖收集 | 自动               | 显式指定           |
| 初始执行 | 立即执行           | 默认不立即执行     |
| 使用场景 | 不关心具体依赖变化 | 需要知道具体变化值 |
| 参数形式 | 单一函数           | 源 + 回调          |

### 6. 可运行完整示例

```vue
<template>
  <div class="watch-effect-demo">
    <h2>WatchEffect Demo</h2>
    
    <!-- 基础用法 -->
    <div class="section">
      <h3>基础用法</h3>
      <p>计数器: {{ count }}</p>
      <button @click="count++">增加</button>
      <div class="console" ref="console1"></div>
    </div>
    
    <!-- 清理副作用 -->
    <div class="section">
      <h3>清理副作用</h3>
      <p>搜索关键词: <input v-model="keyword" /></p>
      <div class="results">
        <p v-for="(result, index) in results" :key="index">{{ result }}</p>
      </div>
    </div>
    
    <!-- 多依赖响应 -->
    <div class="section">
      <h3>多依赖响应</h3>
      <p>X: <input v-model.number="coord.x" type="number" /></p>
      <p>Y: <input v-model.number="coord.y" type="number" /></p>
      <div class="console" ref="console3"></div>
    </div>
    
    <!-- 异步操作 -->
    <div class="section">
      <h3>异步操作</h3>
      <p>用户ID: <input v-model.number="userId" type="number" /></p>
      <div v-if="loading">加载中...</div>
      <div v-else class="user-info">
        <p>用户名: {{ user.name }}</p>
        <p>邮箱: {{ user.email }}</p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, watchEffect } from 'vue'

// 基础用法
const count = ref(0)
const console1 = ref(null)
watchEffect(() => {
  if (console1.value) {
    console1.value.innerHTML += `<p>Count changed to: ${count.value}</p>`
  }
})

// 清理副作用
const keyword = ref('')
const results = ref([])
watchEffect(async (onInvalidate) => {
  const currentKeyword = keyword.value
  if (!currentKeyword.trim()) {
    results.value = []
    return
  }
  
  let cancelled = false
  onInvalidate(() => {
    cancelled = true
  })
  
  // 模拟API请求
  await new Promise(resolve => setTimeout(resolve, 500))
  if (cancelled) return
  
  // 模拟搜索结果
  results.value = Array(3).fill(0).map((_, i) => 
    `结果 ${i+1} 为 "${currentKeyword}${i+1}"`
  )
})

// 多依赖响应
const coord = reactive({ x: 0, y: 0 })
const console3 = ref(null)
watchEffect(() => {
  if (console3.value) {
    const distance = Math.sqrt(coord.x ** 2 + coord.y ** 2)
    console3.value.innerHTML += 
      `<p>坐标变化: (${coord.x}, ${coord.y}), 距离: ${distance.toFixed(2)}</p>`
  }
})

// 异步操作
const userId = ref(1)
const user = reactive({ name: '', email: '' })
const loading = ref(false)
watchEffect(async () => {
  const id = userId.value
  loading.value = true
  
  try {
    // 模拟API请求
    await new Promise(resolve => setTimeout(resolve, 800))
    const users = [
      { id: 1, name: '张三', email: 'zhangsan@example.com' },
      { id: 2, name: '李四', email: 'lisi@example.com' },
      { id: 3, name: '王五', email: 'wangwu@example.com' }
    ]
    const found = users.find(u => u.id === id) || {}
    Object.assign(user, found)
  } finally {
    loading.value = false
  }
})
</script>

<style>
.watch-effect-demo {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}
.section {
  margin-bottom: 30px;
  padding: 15px;
  border: 1px solid #eee;
  border-radius: 5px;
}
button {
  padding: 5px 10px;
  margin-right: 10px;
  cursor: pointer;
}
input {
  padding: 5px;
  margin: 5px;
  width: 200px;
}
.console {
  height: 100px;
  overflow-y: auto;
  border: 1px solid #ddd;
  padding: 5px;
  margin-top: 10px;
  background: #f5f5f5;
}
.results {
  margin-top: 10px;
}
.user-info {
  margin-top: 10px;
}
</style>
```

### 7. watchEffect 的最佳实践

1. **合理使用清理函数**：避免内存泄漏和竞态条件
2. **避免过度使用**：只在需要副作用时使用
3. **性能优化**：对于复杂计算，考虑使用 computed
4. **调试技巧**：利用 onTrack/onTrigger 调试依赖关系

### 8. 总结

watchEffect 是 Vue 响应式系统中处理副作用的核心工具，其核心价值可归纳为：

1. **自动追踪**：智能收集依赖，无需手动指定
2. **即时响应**：立即执行并响应变化
3. **清理机制**：提供完善的副作用清理方案
4. **灵活配置**：支持多种执行时机和调试选项

记住这个简单的口诀：**"副作用用 watchEffect，自动追踪真方便，清理逻辑要记得，性能优化别忽略"**。

watchEffect 的设计体现了 Vue 3 响应式系统的先进性，它将响应式编程的威力与开发者友好性完美结合。在实际项目中，合理使用 watchEffect 可以优雅地处理各种副作用场景，从简单的 DOM 操作到复杂的异步数据流，都能保持代码的清晰和可维护性。

特别提示：watchEffect 在组件卸载时会自动停止，但如果需要在特定条件下手动停止侦听，可以接收 watchEffect 返回的停止函数：

```javascript
const stop = watchEffect(() => {...})
// 需要时调用
stop()
```


## watchPostEffect() 深度解析

`watchPostEffect()` 是 Vue 3.2+ 引入的专门用于 DOM 更新后执行副作用的高级 API，它解决了特定场景下的时序问题。

### 1. watchPostEffect 的基本概念

`watchPostEffect()` 是 `watchEffect()` 的变体，默认将副作用执行时机设置为组件更新**之后**（相当于 `watchEffect(..., { flush: 'post' })`）：

```javascript
import { watchPostEffect } from 'vue'

watchPostEffect(() => {
  // 这里的代码会在 DOM 更新后执行
  console.log('DOM 已更新')
})
```

### 2. watchPostEffect 的核心参数

参数与 `watchEffect()` 完全一致：

1. **effect 函数**：包含副作用的函数
2. **options 对象（可选）**：可覆盖默认的 flush 配置

```javascript
watchPostEffect(
  (onInvalidate) => {
    // 副作用逻辑
    onInvalidate(() => {
      // 清理逻辑
    })
  },
  {
    onTrack(e) { /* 调试用 */ },
    onTrigger(e) { /* 调试用 */ }
  }
)
```

### 3. watchPostEffect 的工作原理

与 watchEffect 的核心区别在于执行时机：

1. **默认 flush: 'post'**：在组件更新后执行
2. **DOM 访问安全**：可以安全访问更新后的 DOM
3. **执行顺序**：在 Vue 的生命周期中的 `updated` 钩子之后执行

```javascript
// 伪代码展示执行时序
function updateComponent() {
  // 响应式数据变更
  // 虚拟DOM重新渲染
  // DOM实际更新
  queuePostFlushCb(() => {
    watchPostEffectCallbacks.forEach(run)
  })
}
```

### 4. watchPostEffect 的典型使用场景

#### 4.1 DOM 测量和布局

```javascript
watchPostEffect(() => {
  const el = document.getElementById('target')
  console.log('元素高度:', el.offsetHeight)
})
```

#### 4.2 第三方库集成

```javascript
watchPostEffect(() => {
  // 确保图表在DOM更新后重新渲染
  chart.resize()
})
```

#### 4.3 动画触发

```javascript
watchPostEffect(() => {
  // 在DOM更新后触发动画
  animate(element, { opacity: [0, 1] })
})
```

### 5. watchPostEffect vs watchEffect

| 特性     | watchPostEffect   | watchEffect       |
| -------- | ----------------- | ----------------- |
| 执行时机 | DOM 更新后        | 默认立即，可配置  |
| 主要用途 | DOM 相关操作      | 通用副作用        |
| 默认配置 | flush: 'post'     | flush: 'pre'      |
| 使用场景 | 需要访问更新后DOM | 不依赖DOM更新时机 |

### 6. 可运行完整示例

```vue
<template>
  <div class="watch-post-effect-demo">
    <h2>WatchPostEffect Demo</h2>
    
    <!-- DOM测量示例 -->
    <div class="section">
      <h3>DOM测量</h3>
      <div ref="box" :style="{ padding: padding + 'px' }">
        动态内容: {{ content }}
      </div>
      <button @click="changePadding">增加内边距</button>
      <div class="console" ref="console1"></div>
    </div>
    
    <!-- 图表集成示例 -->
    <div class="section">
      <h3>图表集成</h3>
      <div ref="chartContainer" style="height: 300px;"></div>
      <button @click="toggleTheme">切换主题</button>
    </div>
    
    <!-- 动画示例 -->
    <div class="section">
      <h3>动画效果</h3>
      <div ref="animBox" class="anim-box"></div>
      <button @click="toggleVisibility">切换显示</button>
    </div>
  </div>
</template>

<script setup>
import { ref, watchPostEffect, onMounted } from 'vue'

// DOM测量示例
const box = ref(null)
const padding = ref(10)
const content = ref('示例文本')
const console1 = ref(null)

function changePadding() {
  padding.value += 5
  content.value += ' 更多'
}

watchPostEffect(() => {
  if (box.value && console1.value) {
    const height = box.value.offsetHeight
    console1.value.innerHTML += 
      `<p>当前内边距: ${padding.value}px, 元素高度: ${height}px</p>`
  }
})

// 图表集成示例
const chartContainer = ref(null)
const isDarkTheme = ref(false)
let chartInstance = null

onMounted(() => {
  // 模拟图表初始化
  chartInstance = {
    resize: () => console.log('图表重绘:', isDarkTheme.value ? '暗色' : '亮色'),
    dispose: () => console.log('清理图表')
  }
})

watchPostEffect(() => {
  if (chartInstance) {
    chartInstance.resize()
  }
})

function toggleTheme() {
  isDarkTheme.value = !isDarkTheme.value
}

// 动画示例
const animBox = ref(null)
const isVisible = ref(true)

function toggleVisibility() {
  isVisible.value = !isVisible.value
}

watchPostEffect(() => {
  if (animBox.value) {
    animBox.value.style.display = isVisible.value ? 'block' : 'none'
    if (isVisible.value) {
      animBox.value.style.animation = 'fadeIn 0.5s'
    }
  }
})
</script>

<style>
.watch-post-effect-demo {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}
.section {
  margin-bottom: 30px;
  padding: 15px;
  border: 1px solid #eee;
  border-radius: 5px;
}
button {
  padding: 5px 10px;
  margin: 5px;
  cursor: pointer;
}
.console {
  height: 100px;
  overflow-y: auto;
  border: 1px solid #ddd;
  padding: 5px;
  margin-top: 10px;
  background: #f5f5f5;
}
.anim-box {
  width: 100px;
  height: 100px;
  background-color: #42b983;
  margin-top: 10px;
}
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}
</style>
```

### 7. watchPostEffect 的注意事项

1. **执行顺序**：多个 watchPostEffect 按注册顺序执行
2. **异步更新**：不会阻塞渲染进程
3. **过度使用**：仅在需要时使用，避免性能问题
4. **组件卸载**：会自动停止，类似 watchEffect

### 8. 总结

watchPostEffect 是 Vue 响应式系统中处理 DOM 相关副作用的高级工具，其核心优势可归纳为：

1. **精准时机**：确保在 DOM 更新后执行
2. **安全访问**：避免读取到过时的 DOM 状态
3. **简化代码**：无需手动设置 flush: 'post'
4. **集成友好**：完美适配第三方库集成需求

记住这个简单的口诀：**"DOM 操作要小心，更新之后再访问，watchPostEffect 来帮忙，时机准确又安全"**。

watchPostEffect 的设计体现了 Vue 对实际开发场景的深入理解，它解决了响应式编程中常见的 DOM 时序问题。在需要基于 DOM 状态执行操作的场景中，使用 watchPostEffect 可以避免许多隐蔽的 bug，特别是在以下场景中特别有用：

- 需要测量 DOM 元素尺寸
- 与依赖 DOM 布局的第三方库集成
- 执行需要在视觉更新后触发的动画
- 实现复杂的 DOM 操作逻辑

特别提示：虽然 watchPostEffect 在大多数情况下是更好的选择，但对于不依赖 DOM 状态的纯数据操作，使用普通的 watchEffect 或 computed 可能更合适，因为它们会在更早的时机执行，减少不必要的延迟。


## watchSyncEffect() 深度解析

`watchSyncEffect()` 是 Vue 3 响应式系统中用于**同步**执行副作用的高级 API，它提供了最即时的响应能力。

### 1. watchSyncEffect 的基本概念

`watchSyncEffect()` 是 `watchEffect()` 的同步变体，默认将副作用执行时机设置为**同步**（相当于 `watchEffect(..., { flush: 'sync' })`）：

```javascript
import { watchSyncEffect } from 'vue'

watchSyncEffect(() => {
  // 这里的代码会在依赖变化时立即同步执行
  console.log('同步执行副作用')
})
```

### 2. watchSyncEffect 的核心参数

参数与 `watchEffect()` 完全一致：

1. **effect 函数**：包含副作用的函数
2. **options 对象（可选）**：可覆盖默认的 flush 配置

```javascript
watchSyncEffect(
  (onInvalidate) => {
    // 副作用逻辑
    onInvalidate(() => {
      // 清理逻辑
    })
  },
  {
    onTrack(e) { /* 调试用 */ },
    onTrigger(e) { /* 调试用 */ }
  }
)
```

### 3. watchSyncEffect 的工作原理

与 watchEffect 的核心区别在于执行时机：

1. **默认 flush: 'sync'**：在依赖变化时**同步**立即执行
2. **执行顺序**：在响应式数据变更的同一事件循环中执行
3. **性能影响**：可能影响渲染性能，需谨慎使用

```javascript
// 伪代码展示执行时序
function triggerEffects(dep) {
  dep.forEach(effect => {
    if (effect.flush === 'sync') {
      effect.run() // 立即同步执行
    } else {
      queueEffect(effect) // 加入队列异步执行
    }
  })
}
```

### 4. watchSyncEffect 的典型使用场景

#### 4.1 需要即时反馈的操作

```javascript
watchSyncEffect(() => {
  // 同步更新本地存储
  localStorage.setItem('settings', JSON.stringify(settings.value))
})
```

#### 4.2 与同步第三方库集成

```javascript
watchSyncEffect(() => {
  // 同步更新非响应式库
  legacyLibrary.setValue(state.value)
})
```

#### 4.3 关键状态验证

```javascript
watchSyncEffect(() => {
  if (invalidState.value) {
    throw new Error('非法状态!')
  }
})
```

### 5. watchSyncEffect vs watchEffect vs watchPostEffect

| 特性     | watchSyncEffect    | watchEffect      | watchPostEffect   |
| -------- | ------------------ | ---------------- | ----------------- |
| 执行时机 | 同步立即执行       | 默认 pre，可配置 | DOM 更新后 (post) |
| 执行顺序 | 当前事件循环       | 下一事件循环     | 渲染完成后        |
| 使用场景 | 需要即时同步的场景 | 通用副作用       | DOM 相关操作      |
| 性能影响 | 高（可能阻塞渲染） | 中               | 低                |

### 6. 可运行完整示例

```vue
<template>
  <div class="watch-sync-effect-demo">
    <h2>WatchSyncEffect Demo</h2>
    
    <!-- 即时本地存储 -->
    <div class="section">
      <h3>即时本地存储</h3>
      <p>主题设置: {{ theme }}</p>
      <button @click="toggleTheme">切换主题</button>
      <div class="console" ref="console1"></div>
    </div>
    
    <!-- 同步验证 -->
    <div class="section">
      <h3>同步验证</h3>
      <input v-model.number="value" type="number" placeholder="输入1-100之间的数字">
      <p v-if="error" class="error">{{ error }}</p>
    </div>
    
    <!-- 与同步库集成 -->
    <div class="section">
      <h3>同步库集成</h3>
      <p>计数器: {{ counter }}</p>
      <button @click="counter++">增加</button>
      <div class="legacy-output">传统库输出: {{ legacyValue }}</div>
    </div>
  </div>
</template>

<script setup>
import { ref, watchSyncEffect } from 'vue'

// 即时本地存储示例
const theme = ref(localStorage.getItem('theme') || 'light')
const console1 = ref(null)

function toggleTheme() {
  theme.value = theme.value === 'light' ? 'dark' : 'light'
}

watchSyncEffect(() => {
  localStorage.setItem('theme', theme.value)
  if (console1.value) {
    console1.value.innerHTML += 
      `<p>主题已同步存储: ${theme.value} (${new Date().toLocaleTimeString()})</p>`
  }
})

// 同步验证示例
const value = ref(50)
const error = ref('')
watchSyncEffect(() => {
  if (value.value < 1 || value.value > 100) {
    error.value = '值必须在1-100之间'
    value.value = Math.min(100, Math.max(1, value.value))
  } else {
    error.value = ''
  }
})

// 同步库集成示例
const counter = ref(0)
const legacyValue = ref(0)

// 模拟传统同步库
const legacyLibrary = {
  setValue(val) {
    console.log('传统库接收值:', val)
    legacyValue.value = val * 2 // 模拟处理
  }
}

watchSyncEffect(() => {
  legacyLibrary.setValue(counter.value)
})
</script>

<style>
.watch-sync-effect-demo {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}
.section {
  margin-bottom: 30px;
  padding: 15px;
  border: 1px solid #eee;
  border-radius: 5px;
}
button {
  padding: 5px 10px;
  margin: 5px;
  cursor: pointer;
}
.console {
  height: 100px;
  overflow-y: auto;
  border: 1px solid #ddd;
  padding: 5px;
  margin-top: 10px;
  background: #f5f5f5;
}
.error {
  color: red;
  margin-top: 5px;
}
.legacy-output {
  margin-top: 10px;
  padding: 5px;
  background: #f0f0f0;
}
</style>
```

### 7. watchSyncEffect 的注意事项

1. **性能影响**：过度使用可能导致性能问题
2. **执行顺序**：多个 watchSyncEffect 按注册顺序同步执行
3. **避免死循环**：小心副作用内修改依赖数据
4. **谨慎使用**：仅在真正需要同步执行的场景使用

### 8. 总结

watchSyncEffect 是 Vue 响应式系统中处理**同步副作用**的特殊工具，其核心价值可归纳为：

1. **即时响应**：提供最快速的响应能力
2. **同步保证**：确保操作在数据变更的同一事件循环中完成
3. **特殊场景**：解决需要即时反馈的边界情况
4. **精准控制**：给予开发者对执行时序的完全控制

记住这个简单的口诀：**"同步执行要小心，watchSyncEffect 显本领，即时反馈很重要，性能影响要记牢"**。

watchSyncEffect 的设计体现了 Vue 对复杂场景的全面考虑，它虽然不常用，但在以下关键场景中不可或缺：

- 需要与同步 API 或传统库集成
- 实现关键状态即时验证
- 处理必须同步完成的操作
- 调试和测试特殊时序问题

特别提示：在大多数常规开发中，应优先考虑使用 watchEffect 或 watchPostEffect，只有在确实需要同步行为时才使用 watchSyncEffect。过度使用可能导致性能下降，因为同步副作用会阻塞渲染进程。

## watch() 深度解析

`watch()` 是 Vue 响应式系统中用于观察特定数据变化并执行副作用的核心 API，它提供了精确的依赖控制和灵活的响应方式。

### 1. watch 的基本概念

`watch()` 用于观察特定的响应式数据源，并在数据变化时执行回调函数：

```javascript
import { ref, watch } from 'vue'

const count = ref(0)

watch(count, (newValue, oldValue) => {
  console.log(`count从${oldValue}变为${newValue}`)
})
```

### 2. watch 的核心参数

`watch()` 接受三个参数：

1. **source**：要观察的数据源（单个或多个）
2. **callback**：变化时执行的回调函数
3. **options**：配置选项（可选）

#### 2.1 数据源类型

```javascript
// 单个ref
watch(refValue, callback)

// getter函数
watch(() => x.value + y.value, callback)

// 多个源组成的数组
watch([ref1, ref2], callback)
```

#### 2.2 回调函数参数

```javascript
watch(source, (newValue, oldValue, onCleanup) => {
  // newValue: 新值
  // oldValue: 旧值
  // onCleanup: 清理函数
})
```

#### 2.3 配置选项

```javascript
watch(source, callback, {
  immediate: false, // 是否立即执行
  deep: false,     // 是否深度观察
  flush: 'pre',    // 执行时机: 'pre' | 'post' | 'sync'
  onTrack(e) { /* 调试用 */ },
  onTrigger(e) { /* 调试用 */ }
})
```

### 3. watch 的工作原理

watch 的核心机制：

1. **依赖追踪**：精确追踪指定的数据源
2. **变化检测**：比较新旧值是否变化
3. **回调执行**：在配置的时机执行回调
4. **清理机制**：提供副作用清理能力

```javascript
// 伪代码展示 watch 实现原理
function myWatch(source, cb, options) {
  let getter = isRef(source) 
    ? () => source.value
    : isFunction(source)
      ? source
      : () => traverse(source) // 处理多源和深度监听
  
  let cleanup
  const job = () => {
    const newValue = getter()
    if (hasChanged(newValue, oldValue)) {
      cb(newValue, oldValue, (fn) => { cleanup = fn })
      oldValue = newValue
    }
  }
  
  // 根据options调度job执行
}
```

### 4. watch 的典型使用场景

#### 4.1 精确观察特定数据

```javascript
watch(
  () => user.id,
  (newId) => fetchUserData(newId)
)
```

#### 4.2 深度观察复杂对象

```javascript
watch(
  () => state.settings,
  (newSettings) => saveSettings(newSettings),
  { deep: true }
)
```

#### 4.3 多源观察

```javascript
watch(
  [firstName, lastName],
  ([newFirst, newLast]) => {
    fullName.value = `${newFirst} ${newLast}`
  }
)
```

### 5. watch vs watchEffect

| 特性     | watch            | watchEffect    |
| -------- | ---------------- | -------------- |
| 依赖指定 | 显式指定         | 自动收集       |
| 新旧值   | 提供新旧值       | 不提供         |
| 立即执行 | 默认否(可配置)   | 默认是         |
| 使用场景 | 需要知道具体变化 | 不关心具体变化 |

### 6. 可运行完整示例

```vue
<template>
  <div class="watch-demo">
    <h2>Watch API Demo</h2>
    
    <!-- 基本用法 -->
    <div class="section">
      <h3>基本用法</h3>
      <p>计数器: {{ counter }}</p>
      <button @click="counter++">增加</button>
      <div class="console" ref="console1"></div>
    </div>
    
    <!-- 深度监听 -->
    <div class="section">
      <h3>深度监听</h3>
      <p>用户信息: {{ user.name }} ({{ user.age }}岁)</p>
      <button @click="updateUser">更新用户</button>
      <div class="console" ref="console2"></div>
    </div>
    
    <!-- 多源监听 -->
    <div class="section">
      <h3>多源监听</h3>
      <p>X: <input v-model.number="coord.x" type="number"></p>
      <p>Y: <input v-model.number="coord.y" type="number"></p>
      <div class="console" ref="console3"></div>
    </div>
    
    <!-- 异步操作 -->
    <div class="section">
      <h3>异步操作</h3>
      <p>搜索: <input v-model="searchQuery" placeholder="输入搜索词"></p>
      <div v-if="searchLoading">搜索中...</div>
      <ul v-else>
        <li v-for="(result, index) in searchResults" :key="index">{{ result }}</li>
      </ul>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, watch } from 'vue'

// 基本用法
const counter = ref(0)
const console1 = ref(null)
watch(counter, (newVal, oldVal) => {
  if (console1.value) {
    console1.value.innerHTML += 
      `<p>计数器从 ${oldVal} 变为 ${newVal}</p>`
  }
})

// 深度监听
const user = reactive({
  name: '张三',
  age: 25,
  address: {
    city: '北京'
  }
})
const console2 = ref(null)
watch(
  () => user,
  (newUser, oldUser) => {
    if (console2.value) {
      console2.value.innerHTML += 
        `<p>用户信息变更: ${newUser.name} 年龄 ${newUser.age}</p>`
    }
  },
  { deep: true }
)

function updateUser() {
  user.age++
  user.address.city = ['北京', '上海', '广州'][user.age % 3]
}

// 多源监听
const coord = reactive({ x: 0, y: 0 })
const console3 = ref(null)
watch(
  [() => coord.x, () => coord.y],
  ([newX, newY], [oldX, oldY]) => {
    if (console3.value) {
      console3.value.innerHTML += 
        `<p>坐标变化: X从 ${oldX}→${newX}, Y从 ${oldY}→${newY}</p>`
    }
  }
)

// 异步操作
const searchQuery = ref('')
const searchResults = ref([])
const searchLoading = ref(false)
let searchController = null

watch(searchQuery, async (newQuery, oldQuery, onCleanup) => {
  if (!newQuery.trim()) {
    searchResults.value = []
    return
  }
  
  searchLoading.value = true
  try {
    // 模拟取消上一次请求
    if (searchController) {
      searchController.abort()
    }
    searchController = new AbortController()
    
    onCleanup(() => {
      searchController.abort()
    })
    
    // 模拟API请求
    await new Promise(resolve => setTimeout(resolve, 500))
    if (searchController.signal.aborted) return
    
    // 模拟搜索结果
    searchResults.value = Array(3).fill(0).map((_, i) => 
      `结果 ${i+1} 为 "${newQuery}${i+1}"`
    )
  } finally {
    searchLoading.value = false
    searchController = null
  }
})
</script>

<style>
.watch-demo {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}
.section {
  margin-bottom: 30px;
  padding: 15px;
  border: 1px solid #eee;
  border-radius: 5px;
}
button {
  padding: 5px 10px;
  margin: 5px;
  cursor: pointer;
}
.console {
  height: 100px;
  overflow-y: auto;
  border: 1px solid #ddd;
  padding: 5px;
  margin-top: 10px;
  background: #f5f5f5;
}
input {
  padding: 5px;
  margin: 5px;
  width: 200px;
}
ul {
  margin-top: 10px;
  padding-left: 20px;
}
</style>
```

### 7. watch 的最佳实践

1. **精确指定依赖**：避免不必要的重新执行
2. **合理使用 deep**：仅在需要时开启深度观察
3. **清理副作用**：使用 onCleanup 避免内存泄漏
4. **性能优化**：避免在 watch 中执行昂贵操作

### 8. 总结

watch 是 Vue 响应式系统中用于精确观察数据变化的核心工具，其核心优势可归纳为：

1. **精确控制**：明确指定要观察的数据源
2. **变化追踪**：提供新旧值对比能力
3. **灵活配置**：支持多种执行时机和观察深度
4. **安全机制**：提供副作用清理功能

记住这个简单的口诀：**"精确观察用 watch，新旧变化都掌握，深度监听按需开，清理函数别忘带"**。

watch 的设计体现了 Vue 响应式系统的灵活性，它既提供了简单的使用方式，又能满足复杂场景的需求。在实际项目中，watch 特别适合以下场景：

- 需要在特定数据变化时执行操作
- 需要比较新旧值来决定是否执行逻辑
- 需要观察嵌套对象或数组的深层变化
- 需要处理异步操作和取消逻辑

特别提示：在组合式 API 中，watch 会自动在组件卸载时停止，但也可以通过 watch 返回的停止函数手动停止观察：

```javascript
const stop = watch(source, callback)
// 需要时调用
stop()
```


## onWatcherCleanup() 深度解析

`onWatcherCleanup()` 实际上是 watch 和 watchEffect 回调中提供的清理函数参数，用于处理副作用的清理工作。

### 1. onWatcherCleanup 的基本概念

在 `watch` 和 `watchEffect` 的回调函数中，接收的第三个参数就是清理函数（通常命名为 `onCleanup`）：

```javascript
watch(source, (newVal, oldVal, onCleanup) => {
  onCleanup(() => {
    // 清理逻辑
  })
})

watchEffect((onCleanup) => {
  onCleanup(() => {
    // 清理逻辑
  })
})
```

### 2. onWatcherCleanup 的核心作用

1. **清理副作用**：取消未完成的异步操作
2. **释放资源**：清除定时器、事件监听等
3. **避免竞态**：防止旧回调影响新状态
4. **内存管理**：防止内存泄漏

### 3. onWatcherCleanup 的工作原理

清理函数的执行时机：

1. **依赖变化时**：在执行新回调前清理旧副作用
2. **观察器停止时**：组件卸载或手动停止观察时
3. **错误发生时**：回调抛出错误前

```javascript
// 伪代码展示清理机制
function runWatchEffect(effect) {
  let cleanup
  
  function wrappedEffect() {
    cleanup?.() // 执行上次的清理
    effect((fn) => { cleanup = fn }) // 设置新的清理
  }
  
  wrappedEffect()
  return () => cleanup?.() // 停止时清理
}
```

### 4. onWatcherCleanup 的典型使用场景

#### 4.1 取消异步请求

```javascript
watch(id, async (newId, oldId, onCleanup) => {
  const controller = new AbortController()
  onCleanup(() => controller.abort())
  
  const data = await fetch(`/api/${newId}`, {
    signal: controller.signal
  })
})
```

#### 4.2 清除定时器

```javascript
watchEffect((onCleanup) => {
  const timer = setInterval(() => {
    console.log('心跳')
  }, 1000)
  
  onCleanup(() => clearInterval(timer))
})
```

#### 4.3 移除事件监听

```javascript
watch(
  () => element.value,
  (el) => {
    const handler = () => console.log('点击')
    el.addEventListener('click', handler)
    
    onCleanup(() => {
      el.removeEventListener('click', handler)
    })
  }
)
```

### 5. 可运行完整示例

```vue
<template>
  <div class="cleanup-demo">
    <h2>onWatcherCleanup Demo</h2>
    
    <!-- 取消异步请求 -->
    <div class="section">
      <h3>取消异步请求</h3>
      <p>用户ID: <input v-model.number="userId" type="number"></p>
      <div v-if="loading">加载中...</div>
      <div v-else class="user-info">
        <p>用户名: {{ user.name }}</p>
        <p>邮箱: {{ user.email }}</p>
      </div>
    </div>
    
    <!-- 定时器清理 -->
    <div class="section">
      <h3>定时器清理</h3>
      <p>计数器: {{ counter }}</p>
      <button @click="toggleTimer">{{ timerActive ? '停止' : '开始' }}定时器</button>
    </div>
    
    <!-- 事件监听清理 -->
    <div class="section">
      <h3>事件监听清理</h3>
      <div ref="clickArea" class="click-area">
        <p>点击区域 (点击次数: {{ clickCount }})</p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, watchEffect } from 'vue'

// 取消异步请求示例
const userId = ref(1)
const user = reactive({ name: '', email: '' })
const loading = ref(false)

watch(userId, async (newId, oldId, onCleanup) => {
  loading.value = true
  let cancelled = false
  
  onCleanup(() => {
    cancelled = true
    loading.value = false
  })
  
  try {
    // 模拟API请求
    await new Promise(resolve => setTimeout(resolve, 1000))
    if (cancelled) return
    
    // 模拟用户数据
    const users = [
      { id: 1, name: '张三', email: 'zhangsan@example.com' },
      { id: 2, name: '李四', email: 'lisi@example.com' },
      { id: 3, name: '王五', email: 'wangwu@example.com' }
    ]
    
    Object.assign(user, users.find(u => u.id === newId) || {})
  } finally {
    if (!cancelled) loading.value = false
  }
})

// 定时器清理示例
const counter = ref(0)
const timerActive = ref(false)

watchEffect((onCleanup) => {
  if (!timerActive.value) return
  
  const timer = setInterval(() => {
    counter.value++
  }, 1000)
  
  onCleanup(() => {
    clearInterval(timer)
    console.log('定时器已清理')
  })
})

function toggleTimer() {
  timerActive.value = !timerActive.value
}

// 事件监听清理示例
const clickArea = ref(null)
const clickCount = ref(0)

watch(
  () => clickArea.value,
  (el) => {
    if (!el) return
    
    const handleClick = () => {
      clickCount.value++
      console.log('区域被点击')
    }
    
    el.addEventListener('click', handleClick)
    
    onCleanup(() => {
      el.removeEventListener('click', handleClick)
      console.log('事件监听已移除')
    })
  }
)
</script>

<style>
.cleanup-demo {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}
.section {
  margin-bottom: 30px;
  padding: 15px;
  border: 1px solid #eee;
  border-radius: 5px;
}
button {
  padding: 5px 10px;
  margin: 5px;
  cursor: pointer;
}
.user-info {
  margin-top: 10px;
}
.click-area {
  padding: 20px;
  border: 1px dashed #ccc;
  cursor: pointer;
}
.click-area:hover {
  background-color: #f5f5f5;
}
</style>
```

### 6. onWatcherCleanup 的注意事项

1. **自动调用**：Vue 会自动在适当时机调用清理函数
2. **幂等设计**：清理函数应可被多次安全调用
3. **执行顺序**：先清理旧副作用再执行新回调
4. **必要操作**：对于异步操作和资源占用必须清理

### 7. 总结

onWatcherCleanup 是 Vue 响应式系统中管理副作用生命周期的关键机制，其核心价值可归纳为：

1. **资源安全**：确保资源正确释放
2. **竞态防护**：避免过时回调影响当前状态
3. **内存管理**：防止内存泄漏
4. **异步控制**：提供取消异步操作的能力

记住这个简单的口诀：**"副作用要清理，onCleanup 来帮你，异步定时和事件，用完释放别忘记"**。

onWatcherCleanup 的设计体现了 Vue 对资源管理的严谨态度，它通过简单的 API 解决了复杂的副作用管理问题。在实际开发中，合理使用清理函数可以：

- 避免组件卸载后继续执行回调
- 防止快速变化导致的竞态条件
- 确保有限的系统资源被正确释放
- 提升应用的整体稳定性和性能

特别提示：虽然 Vue 会在组件卸载时自动清理，但良好的编程习惯是始终为可能产生副作用的操作提供清理函数，特别是在以下场景：

1. 任何异步操作（fetch、setTimeout 等）
2. 自定义事件监听
3. 第三方库的初始化/销毁
4. 手动创建的订阅或观察者
