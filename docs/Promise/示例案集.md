# 示例案集

## EP01

``` ts
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
})
console.log('1', promise1);
```

这段代码展示了 Promise 的基本用法和同步/异步行为。让我们逐步解析：

```javascript
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
})
console.log('1', promise1);
```

### 代码执行过程：

1. **创建 Promise 对象**：
   - 当 `new Promise` 执行时，传入的 executor 函数（`(resolve, reject) => {...}`）会**立即同步执行**
   - 所以会先输出 `'promise1'`

2. **console.log 输出**：
   - 然后执行 `console.log('1', promise1)`
   - 此时 `promise1` 是一个 pending 状态的 Promise 对象

### 输出结果：
```
promise1
1 Promise {<pending>}
```

### 关键点说明：
- Promise 的 executor 函数是**同步执行**的
- 在这个例子中，executor 函数内部没有调用 `resolve` 或 `reject`，所以 Promise 会保持 `pending` 状态
- 第二个 `console.log` 输出时，显示 Promise 的状态是 `<pending>`

### 补充说明：
如果想让 Promise 状态改变，需要调用 resolve 或 reject：
```javascript
const promise2 = new Promise((resolve, reject) => {
  console.log('promise2');
  resolve();
})
console.log('2', promise2); 
// 输出：
// promise2
// 2 Promise {<fulfilled>}
```

这种立即执行的 Promise 有时被称为"热"Promise，因为它开始执行不需要额外的触发。


## EP02
```ts
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve('success')
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
```

这段代码展示了 Promise 的执行顺序，包括同步代码和异步代码的执行流程。让我们逐步解析：

### 代码执行过程：

1. **创建 Promise 对象**：
   ```javascript
   const promise = new Promise((resolve, reject) => {
     console.log(1);       // 同步执行，输出 1
     resolve('success');   // 同步执行，Promise 状态变为 fulfilled
     console.log(2);       // 同步执行，输出 2
   });
   ```
   - `new Promise` 的 executor 函数会**立即同步执行**。
   - 输出 `1` → `resolve('success')` → 输出 `2`。

2. **注册 `.then` 回调**：
   ```javascript
   promise.then(() => {
     console.log(3);       // 微任务，稍后执行
   });
   ```
   - `.then` 的回调是**异步的微任务**，不会立即执行，而是放入微任务队列。

3. **同步代码继续执行**：
   ```javascript
   console.log(4);         // 同步执行，输出 4
   ```
   - 输出 `4`。

4. **微任务执行**：
   - 当前宏任务（同步代码）执行完毕后，开始执行微任务队列中的任务。
   - 执行 `.then` 回调，输出 `3`。

### 输出结果：
```
1
2
4
3
```

### 关键点说明：
1. **Promise 的 executor 函数是同步执行的**：
   - `console.log(1)`、`resolve('success')`、`console.log(2)` 都是同步执行的。

2. **`.then` 回调是异步的微任务**：
   - 即使 Promise 已经 `resolve`，`.then` 回调也不会立即执行，而是等待当前宏任务执行完毕后才会执行。

3. **事件循环的顺序**：
   - 同步代码（宏任务）→ 微任务（Promise 回调）→ 宏任务（如 `setTimeout`）。

### 扩展：如果加上 `setTimeout`
```javascript
console.log(4);
setTimeout(() => console.log(5));  // 宏任务
```

输出顺序会是：
```
1
2
4
3
5
```
因为 `setTimeout` 是宏任务，会在微任务（`3`）之后执行。


## EP03

这段代码展示了 **Promise 的执行顺序**，包括同步代码和异步代码的执行流程。让我们逐步解析：

### 代码执行过程：

1. **创建 Promise 对象**：
   ```javascript
   const promise = new Promise((resolve, reject) => {
     console.log(1);  // 同步执行，输出 1
     console.log(2);  // 同步执行，输出 2
   });
   ```
   - `new Promise` 的 **executor 函数是同步执行的**，所以会立即执行 `console.log(1)` 和 `console.log(2)`。
   - **但 Promise 没有被 `resolve` 或 `reject`**，所以它的状态仍然是 `pending`。

2. **注册 `.then` 回调**：
   ```javascript
   promise.then(() => {
     console.log(3);  // 微任务，但不会执行，因为 Promise 未 resolve/reject
   });
   ```
   - `.then` 的回调是**微任务**，但**只有当 Promise 被 `resolve` 或 `reject` 时才会执行**。
   - 由于 Promise 仍然是 `pending`，`console.log(3)` **不会执行**。

3. **同步代码继续执行**：
   ```javascript
   console.log(4);  // 同步执行，输出 4
   ```
   - 输出 `4`。

### 最终输出：
```
1
2
4
```

### 关键点说明：
1. **Promise 的 executor 函数是同步执行的**：
   - `console.log(1)` 和 `console.log(2)` 会立即执行。

2. **`.then` 回调只有在 Promise 状态改变时才会执行**：
   - 如果 Promise **没有 `resolve` 或 `reject`**，`.then` 回调不会触发。

3. **`console.log(3)` 不会执行**：
   - 因为 Promise 一直是 `pending`，没有进入微任务队列。

### 对比：如果 Promise 被 `resolve`
```javascript
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve();  // 状态变为 fulfilled
  console.log(2);
});
promise.then(() => {
  console.log(3);  // 微任务，会在同步代码执行完毕后执行
});
console.log(4);
```
**输出顺序**：
```
1
2
4
3
```
- 因为 `resolve()` 被调用，`.then` 回调会在同步代码执行完后执行。


## EP04
```ts
const fn = () => (new Promise((resolve, reject) => {
  console.log(1);
  resolve('success')
}))
fn().then(res => {
  console.log(res)
})
console.log('start')
```

这段代码展示了 **Promise 的执行顺序**，包括同步代码和异步代码的执行流程。让我们逐步解析：

### 代码执行过程：

1. **定义 `fn` 函数**：
   ```javascript
   const fn = () => (new Promise((resolve, reject) => {
     console.log(1);        // 同步执行，输出 1
     resolve('success');    // 同步执行，Promise 状态变为 fulfilled
   }));
   ```
   - `fn` 是一个函数，返回一个 `Promise`。
   - 当 `fn()` 被调用时，`new Promise` 的 **executor 函数会同步执行**，所以 `console.log(1)` 会立即执行。
   - `resolve('success')` 也会同步执行，Promise 状态变为 `fulfilled`。

2. **调用 `fn()` 并注册 `.then` 回调**：
   ```javascript
   fn().then(res => {
     console.log(res);      // 微任务，稍后执行
   });
   ```
   - `fn()` 返回一个已经 `resolve('success')` 的 Promise。
   - `.then` 的回调是**微任务**，不会立即执行，而是放入微任务队列。

3. **同步代码继续执行**：
   ```javascript
   console.log('start');    // 同步执行，输出 'start'
   ```
   - 输出 `'start'`。

4. **微任务执行**：
   - 当前宏任务（同步代码）执行完毕后，开始执行微任务队列中的任务。
   - 执行 `.then` 回调，输出 `'success'`（`res` 的值）。

### 最终输出：
```
1
start
success
```

### 关键点说明：
1. **`new Promise` 的 executor 函数是同步执行的**：
   - `console.log(1)` 和 `resolve('success')` 会立即执行。

2. **`.then` 回调是异步的微任务**：
   - 即使 Promise 已经 `resolve`，`.then` 回调也不会立即执行，而是等待当前宏任务执行完毕。

3. **事件循环的顺序**：
   - 同步代码（宏任务）→ 微任务（Promise 回调）→ 宏任务（如 `setTimeout`）。

### 扩展：如果加上 `setTimeout`
```javascript
console.log('start');
setTimeout(() => console.log('timeout'));  // 宏任务
```
输出顺序会是：
```
1
start
success
timeout
```
因为 `setTimeout` 是宏任务，会在微任务（`success`）之后执行。

## EP5

```ts
const promise = new Promise((resolve, reject) => {
  reject("error");
  resolve("success2");
});
promise
.then(res => {
    console.log("then1: ", res);
  }).then(res => {
    console.log("then2: ", res);
  }).catch(err => {
    console.log("catch: ", err);
  }).then(res => {
    console.log("then3: ", res);
  })
```

这段代码展示了 **Promise 链式调用** 的执行流程，特别是 `reject` 和 `catch` 的处理逻辑。让我们逐步解析：

### 代码执行过程：

1. **创建 Promise 并立即 `reject`**：
   ```javascript
   const promise = new Promise((resolve, reject) => {
     reject("error");      // Promise 状态变为 rejected
     resolve("success2");  // 无效，因为 Promise 状态已经锁定
   });
   ```
   - `reject("error")` 会立即将 Promise 状态设为 `rejected`，并携带错误信息 `"error"`。
   - `resolve("success2")` **不会生效**，因为 Promise 的状态一旦改变（`rejected` 或 `fulfilled`），就不能再改变。

2. **链式调用 `.then` 和 `.catch`**：
   ```javascript
   promise
     .then(res => {
       console.log("then1: ", res);  // 跳过，因为 Promise 已 rejected
     })
     .then(res => {
       console.log("then2: ", res);  // 跳过
     })
     .catch(err => {
       console.log("catch: ", err);  // 捕获错误，输出 "catch: error"
     })
     .then(res => {
       console.log("then3: ", res);  // 执行，输出 "then3: undefined"
     });
   ```

### 执行流程解析：
1. **`reject("error")`**：
   - Promise 直接进入 `rejected` 状态，后续的 `resolve("success2")` 被忽略。

2. **第一个 `.then`**：
   - 由于 Promise 是 `rejected`，第一个 `.then` 的回调（`then1`）**不会执行**，直接跳到后续的 `.catch`。

3. **第二个 `.then`**：
   - 由于前一个 `.then` 被跳过，第二个 `.then`（`then2`）**也不会执行**。

4. **`.catch`**：
   - 捕获到 `reject("error")` 的错误，输出 `"catch: error"`。
   - `.catch` 返回一个新的 Promise，默认是 `fulfilled` 状态（除非 `.catch` 内部抛出错误）。

5. **最后一个 `.then`（`then3`）**：
   - 由于 `.catch` 没有显式返回任何值，`res` 是 `undefined`，所以输出 `"then3: undefined"`。

### 最终输出：
```
catch: error
then3: undefined
```

### 关键点总结：
1. **Promise 状态一旦改变（`rejected`/`fulfilled`），就不能再改变**。
   - `reject("error")` 后，`resolve("success2")` 无效。

2. **`.then` 只有在 Promise 是 `fulfilled` 时才会执行**：
   - 如果 Promise 是 `rejected`，`.then` 会被跳过，直接进入 `.catch`。

3. **`.catch` 会捕获之前的错误，并返回一个新的 `fulfilled` Promise**：
   - 除非 `.catch` 内部再次抛出错误，否则后续的 `.then` 会正常执行。

4. **如果 `.then` 或 `.catch` 没有返回值，`res` 会是 `undefined`**：
   - 最后一个 `then3` 的 `res` 是 `undefined`，因为 `.catch` 没有返回任何值。

### 扩展：如果 `.catch` 返回一个值
```javascript
.catch(err => {
  console.log("catch: ", err);
  return "recovered";  // 返回一个值
})
.then(res => {
  console.log("then3: ", res);  // 输出 "then3: recovered"
})
```
**输出**：
```
catch: error
then3: recovered
```
- 因为 `.catch` 返回了 `"recovered"`，所以 `then3` 的 `res` 是这个值。

## EP06

```ts
const fn = () =>
  new Promise((resolve, reject) => {
    console.log(1);
    resolve("success");
  });
console.log("start");
fn().then(res => {
  console.log(res);
});
```

这段代码的执行顺序涉及 **同步代码** 和 **Promise 的异步执行机制**。让我们一步步分析：

### 代码执行流程：

1. **定义 `fn` 函数（同步）**：
   ```javascript
   const fn = () =>
     new Promise((resolve, reject) => {
       console.log(1);        // 同步代码（在 Promise 构造时执行）
       resolve("success");    // 同步执行，Promise 状态变为 fulfilled
     });
   ```
   - `fn` 是一个返回 Promise 的函数，但此时**函数尚未调用**，所以 `console.log(1)` 还没执行。

2. **同步代码 `console.log("start")`**：
   ```javascript
   console.log("start");      // 同步代码，立即执行
   ```
   - 输出 `"start"`。

3. **调用 `fn()`（同步 + 异步）**：
   ```javascript
   fn().then(res => {        // 调用 fn()，触发 Promise 执行
     console.log(res);       // 异步微任务，稍后执行
   });
   ```
   - `fn()` 调用时，`new Promise` 的 **executor 函数同步执行**：
     - 输出 `1`。
     - `resolve("success")` 将 Promise 状态设为 `fulfilled`。
   - `.then(res => { console.log(res) })` 是**微任务**，不会立即执行，而是放入微任务队列。

4. **微任务执行**：
   - 当前**宏任务（同步代码）执行完毕后**，开始执行微任务队列。
   - 执行 `.then` 回调，输出 `"success"`（`res` 的值）。

### 最终输出顺序：
```
start
1
success
```

### 关键点解析：
1. **`new Promise` 的 executor 函数是同步执行的**：
   - 当 `fn()` 被调用时，`console.log(1)` 和 `resolve("success")` 会立即执行。

2. **`.then` 回调是异步的微任务**：
   - 即使 Promise 已经 `resolve`，`.then` 回调也要等到同步代码执行完毕后才会执行。

3. **事件循环的顺序**：
   - 同步代码（`console.log("start")`）→ Promise 的同步部分（`console.log(1)`）→ 微任务（`.then` 回调）。

### 常见误区：
- **误以为 `console.log(1)` 会在 `console.log("start")` 之前执行**：  
  实际上，`fn` 函数只有被调用时才会执行内部的代码，而 `console.log("start")` 是在调用 `fn()` 之前执行的同步代码。

- **误以为 `console.log(res)` 会立即执行**：  
  `.then` 是异步的，必须等待当前调用栈清空（即同步代码执行完毕）后才会执行。

### 总结：
Promise 的 **executor 函数（`new Promise` 内部的函数）是同步执行的**，但 **`.then`/`.catch` 是异步的微任务**。理解这一点是掌握 Promise 执行顺序的关键！

## EP07
```ts
console.log('start')
setTimeout(() => {
  console.log('time')
})
Promise.resolve().then(() => {
  console.log('resolve')
})
console.log('end')
```

这段代码的执行顺序涉及 **同步代码、微任务（Microtask）和宏任务（Macrotask）** 的执行机制。让我们一步步分析：

---

### **代码执行流程：**

1. **同步代码执行**：
   ```javascript
   console.log('start')    // 同步代码，立即执行
   ```
   - **输出**: `'start'`

2. **`setTimeout` 安排宏任务**：
   ```javascript
   setTimeout(() => {
     console.log('time')   // 宏任务，放入任务队列
   })
   ```
   - `setTimeout` 的回调是**宏任务**，会被放入 **宏任务队列**，等待当前调用栈清空后执行。

3. **`Promise.resolve().then` 安排微任务**：
   ```javascript
   Promise.resolve().then(() => {
     console.log('resolve')  // 微任务，放入微任务队列
   })
   ```
   - `Promise.resolve().then` 的回调是**微任务**，会被放入 **微任务队列**，优先级高于宏任务。

4. **同步代码继续执行**：
   ```javascript
   console.log('end')      // 同步代码，立即执行
   ```
   - **输出**: `'end'`

5. **当前调用栈清空，开始检查微任务队列**：
   - 微任务队列中有 `() => { console.log('resolve') }`，所以执行它。
   - **输出**: `'resolve'`

6. **微任务队列清空后，执行宏任务**：
   - 宏任务队列中有 `setTimeout` 的回调，所以执行它。
   - **输出**: `'time'`

---

### **最终输出顺序：**
```
start
end
resolve
time
```

---

### **关键点解析：**
1. **同步代码最先执行**：
   - `console.log('start')` 和 `console.log('end')` 是同步代码，会立即执行。

2. **微任务（Microtask）优先于宏任务（Macrotask）**：
   - `Promise.then` 是微任务，`setTimeout` 是宏任务。
   - **微任务会在当前宏任务执行完毕后立即执行**，而宏任务要等到下一个事件循环。

3. **事件循环（Event Loop）的顺序**：
   - 同步代码（宏任务的一部分）→ 微任务 → 宏任务（如 `setTimeout`）。

---

### **扩展：如果代码更复杂**
```javascript
console.log('start')

setTimeout(() => {
  console.log('timeout1')
  Promise.resolve().then(() => {
    console.log('promise1 in timeout')
  })
}, 0)

Promise.resolve().then(() => {
  console.log('promise1')
  setTimeout(() => {
    console.log('timeout2 in promise')
  }, 0)
})

console.log('end')
```
**输出顺序**：
```
start
end
promise1
timeout1
promise1 in timeout
timeout2 in promise
```
- **原因**：
  1. 同步代码 `start` → `end`。
  2. 微任务 `promise1` 先执行。
  3. 宏任务 `timeout1` 执行，并在其中产生新的微任务 `promise1 in timeout`。
  4. 微任务优先级高，所以 `promise1 in timeout` 先于 `timeout2 in promise` 执行。

---

### **总结**
- **同步代码 > 微任务（`Promise.then`） > 宏任务（`setTimeout`）**。
- 微任务会在当前宏任务结束后立即执行，而宏任务要等到下一个事件循环。
- 掌握这个顺序是理解 JavaScript 异步编程的关键！

## EP07
```ts
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("success");
    console.log("timer1");
  }, 1000);
  console.log("promise1里的内容");
});
const promise2 = promise1.then(() => {
  throw new Error("error!!!");
});
console.log("promise1", promise1);
console.log("promise2", promise2);
setTimeout(() => {
  console.log("timer2");
  console.log("promise1", promise1);
  console.log("promise2", promise2);
}, 2000);
```

这段代码涉及 **Promise 的异步执行、链式调用、错误处理和 `setTimeout` 的执行顺序**。让我们一步步分析执行流程和输出结果。

---

## **代码执行流程分析**

### **1. 创建 `promise1`**
```javascript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("success");    // 1秒后 resolve
    console.log("timer1"); // 1秒后输出
  }, 1000);
  console.log("promise1里的内容");  // 同步代码，立即执行
});
```
- **同步执行部分**：
  - `console.log("promise1里的内容")` → **输出 `"promise1里的内容"`**
- **异步部分**：
  - `setTimeout` 的回调会在 **1秒后** 执行：
    - `resolve("success")` → `promise1` 状态变为 `fulfilled`
    - `console.log("timer1")` → **输出 `"timer1"`**

---

### **2. `promise1.then()` 创建 `promise2`**
```javascript
const promise2 = promise1.then(() => {
  throw new Error("error!!!");  // 抛出错误，promise2 变为 rejected
});
```
- `promise1.then()` 返回一个新的 Promise（`promise2`）。
- **此时 `promise1` 还是 `pending` 状态**，所以 `promise2` 也处于 `pending` 状态。
- 当 `promise1` 在 **1秒后** `resolve("success")`，`then` 回调执行：
  - `throw new Error("error!!!")` → `promise2` 变为 `rejected`，错误信息是 `"error!!!"`。

---

### **3. 同步输出 `promise1` 和 `promise2`**
```javascript
console.log("promise1", promise1);
console.log("promise2", promise2);
```
- **此时 `promise1` 的状态**：
  - `pending`（因为 `resolve` 在 `setTimeout` 里，还没执行）
- **此时 `promise2` 的状态**：
  - `pending`（因为 `promise1` 还没 `resolve`）
- **输出**：
  ```
  promise1 Promise { <pending> }
  promise2 Promise { <pending> }
  ```

---

### **4. 第二个 `setTimeout`（2秒后执行）**
```javascript
setTimeout(() => {
  console.log("timer2");
  console.log("promise1", promise1);
  console.log("promise2", promise2);
}, 2000);
```
- **2秒后**，执行回调：
  1. `console.log("timer2")` → **输出 `"timer2"`**
  2. **检查 `promise1` 的状态**：
     - 1秒时 `promise1` 已经 `resolve("success")`，所以现在是 `fulfilled`。
     - **输出**：
       ```
       promise1 Promise { "success" }
       ```
  3. **检查 `promise2` 的状态**：
     - `promise1.then()` 的回调抛出了错误，所以 `promise2` 是 `rejected`。
     - **输出**：
       ```
       promise2 Promise { <rejected> Error: error!!! }
       ```

---

## **最终输出顺序**
1. `"promise1里的内容"`（同步代码）
2. `"promise1 Promise { <pending> }"`（同步代码）
3. `"promise2 Promise { <pending> }"`（同步代码）
4. `"timer1"`（1秒后，`promise1` 的 `setTimeout`）
5. `"timer2"`（2秒后，第二个 `setTimeout`）
6. `"promise1 Promise { "success" }"`（`promise1` 已 `resolve`）
7. `"promise2 Promise { <rejected> Error: error!!! }"`（`promise2` 因错误被 `rejected`）

### **完整输出：**
```
promise1里的内容
promise1 Promise { <pending> }
promise2 Promise { <pending> }
timer1
timer2
promise1 Promise { "success" }
promise2 Promise { <rejected> Error: error!!! }
```

---

## **关键点总结**
1. **`new Promise` 的 executor 函数是同步执行的**，但 `resolve`/`reject` 可能是异步的（如放在 `setTimeout` 里）。
2. **`promise.then()` 返回一个新的 Promise**，它的状态取决于回调的执行情况：
   - 如果回调抛出错误（`throw`），新 Promise 会 `rejected`。
3. **`setTimeout` 是宏任务**，`Promise.then` 是微任务：
   - 微任务会在当前宏任务结束后立即执行，而宏任务要等下一个事件循环。
4. **Promise 的状态变化是异步的**，所以同步代码执行时可能还是 `pending`。

---

## **扩展思考**
如果 `promise1.then()` 里不抛出错误，而是返回一个值：
```javascript
const promise2 = promise1.then(() => {
  return "new value";
});
```
**`promise2` 的状态会是什么？**
- `promise2` 会 `resolve("new value")`，输出：
  ```
  promise2 Promise { "new value" }
  ```

---

### **总结**
- **同步代码最先执行**。
- **`Promise` 的状态变化可能是异步的**（如 `setTimeout` 里的 `resolve`）。
- **`promise.then()` 返回的新 Promise 的状态取决于回调的执行情况**（正常返回 → `fulfilled`，抛出错误 → `rejected`）。
- **微任务（`Promise.then`）优先于宏任务（`setTimeout`）执行**。

掌握这些概念，就能轻松分析复杂的 Promise 执行顺序！ 🚀

## EP09
```ts
const promise = new Promise((resolve, reject) => {
  resolve("success1");
  reject("error");
  resolve("success2");
});
promise
.then(res => {
    console.log("then: ", res);
  }).catch(err => {
    console.log("catch: ", err);
  })
```

这段代码展示了 **Promise 的状态变化规则** 和 **链式调用的执行顺序**。让我们一步步分析它的执行流程和输出结果。

---

## **代码执行流程分析**

### **1. `new Promise` 的同步执行**
```javascript
const promise = new Promise((resolve, reject) => {
  resolve("success1");  // Promise 状态变为 fulfilled
  reject("error");      // 无效，因为状态已经锁定
  resolve("success2");  // 无效，因为状态已经锁定
});
```
- **`resolve("success1")`**：
  - **Promise 状态立即变为 `fulfilled`**，并且值设为 `"success1"`。
- **`reject("error")` 和 `resolve("success2")`**：
  - **不会生效**，因为 Promise 的状态一旦改变（`fulfilled` 或 `rejected`），就不能再更改。

---

### **2. `promise.then().catch()` 链式调用**
```javascript
promise
  .then(res => {
    console.log("then: ", res);  // 执行，因为 promise 是 fulfilled
  })
  .catch(err => {
    console.log("catch: ", err); // 不会执行
  });
```
- **`.then` 回调执行**：
  - 因为 `promise` 已经是 `fulfilled`，所以 `then` 的回调会执行，并接收 `"success1"`。
  - **输出**：
    ```
    then: success1
    ```
- **`.catch` 不会执行**：
  - 因为 `promise` 没有进入 `rejected` 状态，且 `.then` 也没有抛出错误。

---

## **最终输出**
```
then: success1
```

---

## **关键点总结**
1. **Promise 的状态一旦改变（`fulfilled` 或 `rejected`），就不能再更改**：
   - `resolve("success1")` 之后，`reject("error")` 和 `resolve("success2")` **无效**。
2. **`.then` 只会在 Promise `fulfilled` 时执行**：
   - 这里 `promise` 已经 `resolve("success1")`，所以 `.then` 回调执行。
3. **`.catch` 只会在 Promise `rejected` 或前面的 `.then` 抛出错误时执行**：
   - 这里没有错误发生，所以 `.catch` 不会执行。
4. **Promise 的 executor 函数（`new Promise` 里的函数）是同步执行的**：
   - `resolve("success1")` 是同步调用的，而不是异步的。

---

## **扩展思考**
### **如果 `resolve` 是异步的（比如放在 `setTimeout` 里）？**
```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("success1");
    reject("error");
  }, 1000);
});
promise
  .then(res => console.log("then:", res))
  .catch(err => console.log("catch:", err));
```
**输出**：
```
then: success1
```
- 虽然 `reject("error")` 在 `resolve("success1")` 之后调用，但 **`resolve` 已经锁定状态**，`reject` 不会生效。

---

### **如果 `then` 抛出错误，`catch` 会捕获吗？**
```javascript
const promise = new Promise((resolve, reject) => {
  resolve("success1");
});
promise
  .then(res => {
    console.log("then:", res);
    throw new Error("oops!");  // 抛出错误
  })
  .catch(err => {
    console.log("catch:", err);  // 捕获错误
  });
```
**输出**：
```
then: success1
catch: Error: oops!
```
- **`then` 抛出错误会导致链式调用的下一个 `.catch` 执行**。

---

## **总结**
- **Promise 的状态只能改变一次**（`resolve` 或 `reject` 后不能再更改）。
- **`.then` 在 `fulfilled` 时执行，`.catch` 在 `rejected` 时执行**。
- **如果 `then` 抛出错误，会被后续的 `catch` 捕获**。
- **Promise 的 executor 函数（`new Promise` 里的代码）是同步执行的**，但 `then/catch` 是异步的（微任务）。

掌握这些规则，就能轻松分析 Promise 的执行顺序！ 🚀


## EP10
```ts
Promise.resolve(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    return 3;
  })
  .then(res => {
    console.log(res);
  });
```
这段代码展示了 **Promise 链式调用** 的执行流程，特别是 `.then` 和 `.catch` 的调用顺序以及返回值的影响。让我们一步步分析它的执行过程和输出结果。

---

## **代码执行流程分析**

### **1. `Promise.resolve(1)`**
```javascript
Promise.resolve(1)
```
- **`Promise.resolve(1)`** 创建一个 **立即 `fulfilled` 的 Promise**，其值为 `1`。

---

### **2. 第一个 `.then`**
```javascript
.then(res => {
  console.log(res);  // 输出 1
  return 2;          // 返回 2，使下一个 `.then` 接收 2
})
```
- **`res` 是 `1`**（来自 `Promise.resolve(1)`）。
- **输出 `1`**。
- **返回 `2`**，这会使得下一个 `.then` 接收 `2`。

---

### **3. `.catch`（被跳过）**
```javascript
.catch(err => {
  return 3;  // 不会执行，因为前面的 `.then` 没有抛出错误
})
```
- **`.catch` 不会执行**，因为前面的 `.then` 没有抛出错误。
- 如果前面的 `.then` 抛出错误（如 `throw new Error()`），`.catch` 才会执行。

---

### **4. 第二个 `.then`**
```javascript
.then(res => {
  console.log(res);  // 输出 2（来自第一个 `.then` 的返回值）
})
```
- **`res` 是 `2`**（来自第一个 `.then` 的返回值）。
- **输出 `2`**。

---

## **最终输出**
```
1
2
```

---

## **关键点总结**
1. **`Promise.resolve(value)`**：
   - 创建一个 **立即 `fulfilled` 的 Promise**，值为 `value`（这里是 `1`）。
2. **`.then` 的执行顺序**：
   - 前一个 `.then` 的返回值会传递给下一个 `.then`。
   - 如果 `.then` 返回普通值（如 `return 2`），下一个 `.then` 会接收这个值。
3. **`.catch` 的执行条件**：
   - 只有当之前的 `.then` 抛出错误（`throw`）或 Promise 被 `reject` 时，`.catch` 才会执行。
   - 在这个例子中，**`.catch` 被跳过**，因为前面的 `.then` 没有错误。
4. **Promise 链式调用的数据流**：
   ```
   Promise.resolve(1) → then(1) → return 2 → then(2)
   ```

---

## **扩展思考**
### **如果第一个 `.then` 抛出错误会发生什么？**
```javascript
Promise.resolve(1)
  .then(res => {
    console.log(res);  // 输出 1
    throw new Error("Oops!");  // 抛出错误
  })
  .catch(err => {
    console.log("catch:", err.message);  // 捕获错误
    return 3;  // 返回 3，使下一个 `.then` 接收 3
  })
  .then(res => {
    console.log(res);  // 输出 3
  });
```
**输出**：
```
1
catch: Oops!
3
```
- **`.catch` 捕获错误后，可以返回新值**，继续链式调用。

---

### **如果 `.catch` 也抛出错误会发生什么？**
```javascript
Promise.resolve(1)
  .then(res => {
    console.log(res);
    throw new Error("First error");
  })
  .catch(err => {
    console.log("catch:", err.message);
    throw new Error("Second error");  // `.catch` 也抛出错误
  })
  .then(res => {
    console.log("then:", res);  // 不会执行
  })
  .catch(err => {
    console.log("final catch:", err.message);  // 捕获第二个错误
  });
```
**输出**：
```
1
catch: First error
final catch: Second error
```
- **错误会一直传递到最后一个 `.catch`**。

---

## **总结**
- **`Promise.resolve()`** 创建一个 `fulfilled` 的 Promise。
- **`.then`** 用于处理 `fulfilled` 状态，返回值会传递给下一个 `.then`。
- **`.catch`** 用于处理 `rejected` 状态，可以捕获前面的错误。
- **错误会沿着 Promise 链传递**，直到被 `.catch` 捕获。
- **如果 `.then` 或 `.catch` 返回普通值**，下一个 `.then` 会接收它。

掌握这些规则，就能轻松分析 Promise 的执行顺序！ 🚀


## EP11
```ts
Promise.reject(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    console.log(err);
    return 3
  })
  .then(res => {
    console.log(res);
  });
```

这段代码展示了 **Promise 的错误处理机制** 和 **链式调用的执行顺序**。让我们一步步分析它的执行过程和输出结果。

---

## **代码执行流程分析**

### **1. `Promise.reject(1)`**
```javascript
Promise.reject(1)
```
- **`Promise.reject(1)`** 创建一个 **立即 `rejected` 的 Promise**，其值为 `1`。

---

### **2. 第一个 `.then`（被跳过）**
```javascript
.then(res => {
  console.log(res);  // 不会执行，因为 Promise 是 rejected
  return 2;
})
```
- **`.then` 不会执行**，因为 `Promise.reject(1)` 的状态是 `rejected`，`.then` 只处理 `fulfilled` 状态。

---

### **3. `.catch`（捕获错误）**
```javascript
.catch(err => {
  console.log(err);  // 输出 1（来自 `Promise.reject(1)`）
  return 3;          // 返回 3，使下一个 `.then` 接收 3
})
```
- **`err` 是 `1`**（来自 `Promise.reject(1)`）。
- **输出 `1`**。
- **返回 `3`**，这会使得下一个 `.then` 接收 `3`。

---

### **4. 第二个 `.then`**
```javascript
.then(res => {
  console.log(res);  // 输出 3（来自 `.catch` 的返回值）
})
```
- **`res` 是 `3`**（来自 `.catch` 的返回值）。
- **输出 `3`**。

---

## **最终输出**
```
1
3
```

---

## **关键点总结**
1. **`Promise.reject(value)`**：
   - 创建一个 **立即 `rejected` 的 Promise**，值为 `value`（这里是 `1`）。
2. **`.then` 的执行条件**：
   - 只有当 Promise 是 `fulfilled` 时，`.then` 才会执行。
   - 如果 Promise 是 `rejected`，`.then` 会被跳过，直接进入 `.catch`。
3. **`.catch` 的执行条件**：
   - 当 Promise 是 `rejected` 或前面的 `.then` 抛出错误时，`.catch` 会执行。
   - **`.catch` 可以返回一个新值**，使后续的 `.then` 继续执行。
4. **Promise 链式调用的数据流**：
   ```
   Promise.reject(1) → catch(1) → return 3 → then(3)
   ```

---

## **扩展思考**
### **如果 `.catch` 不返回任何值会发生什么？**
```javascript
Promise.reject(1)
  .catch(err => {
    console.log(err);  // 输出 1
    // 没有 return，相当于返回 undefined
  })
  .then(res => {
    console.log(res);  // 输出 undefined
  });
```
**输出**：
```
1
undefined
```
- **如果 `.catch` 不返回任何值**，后续的 `.then` 会接收 `undefined`。

---

### **如果 `.catch` 抛出错误会发生什么？**
```javascript
Promise.reject(1)
  .catch(err => {
    console.log(err);  // 输出 1
    throw new Error("Oops!");  // 抛出错误
  })
  .then(res => {
    console.log(res);  // 不会执行
  })
  .catch(err => {
    console.log(err.message);  // 输出 "Oops!"
  });
```
**输出**：
```
1
Oops!
```
- **`.catch` 抛出错误后**，后续的 `.then` 会被跳过，错误会被下一个 `.catch` 捕获。

---

## **总结**
- **`Promise.reject()`** 创建一个 `rejected` 的 Promise。
- **`.then` 只处理 `fulfilled` 状态**，如果 Promise 是 `rejected`，`.then` 会被跳过。
- **`.catch` 处理 `rejected` 状态**，可以捕获错误并返回新值，使后续的 `.then` 继续执行。
- **错误会沿着 Promise 链传递**，直到被 `.catch` 捕获。

掌握这些规则，就能轻松分析 Promise 的执行顺序！ 🚀
