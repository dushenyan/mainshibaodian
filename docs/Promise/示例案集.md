# 示例案集

## EP01

``` ts
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
})
console.log('1', promise1);
```

这段代码展示了 Promise 的基本用法和同步/异步行为。让我们逐步解析：

```javascript
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
})
console.log('1', promise1);
```

### 代码执行过程：

1. **创建 Promise 对象**：
   - 当 `new Promise` 执行时，传入的 executor 函数（`(resolve, reject) => {...}`）会**立即同步执行**
   - 所以会先输出 `'promise1'`

2. **console.log 输出**：
   - 然后执行 `console.log('1', promise1)`
   - 此时 `promise1` 是一个 pending 状态的 Promise 对象

### 输出结果：
```
promise1
1 Promise {<pending>}
```

### 关键点说明：
- Promise 的 executor 函数是**同步执行**的
- 在这个例子中，executor 函数内部没有调用 `resolve` 或 `reject`，所以 Promise 会保持 `pending` 状态
- 第二个 `console.log` 输出时，显示 Promise 的状态是 `<pending>`

### 补充说明：
如果想让 Promise 状态改变，需要调用 resolve 或 reject：
```javascript
const promise2 = new Promise((resolve, reject) => {
  console.log('promise2');
  resolve();
})
console.log('2', promise2); 
// 输出：
// promise2
// 2 Promise {<fulfilled>}
```

这种立即执行的 Promise 有时被称为"热"Promise，因为它开始执行不需要额外的触发。


## EP02
```ts
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve('success')
  console.log(2);
});
promise.then(() => {
  console.log(3);
});
console.log(4);
```

这段代码展示了 Promise 的执行顺序，包括同步代码和异步代码的执行流程。让我们逐步解析：

### 代码执行过程：

1. **创建 Promise 对象**：
   ```javascript
   const promise = new Promise((resolve, reject) => {
     console.log(1);       // 同步执行，输出 1
     resolve('success');   // 同步执行，Promise 状态变为 fulfilled
     console.log(2);       // 同步执行，输出 2
   });
   ```
   - `new Promise` 的 executor 函数会**立即同步执行**。
   - 输出 `1` → `resolve('success')` → 输出 `2`。

2. **注册 `.then` 回调**：
   ```javascript
   promise.then(() => {
     console.log(3);       // 微任务，稍后执行
   });
   ```
   - `.then` 的回调是**异步的微任务**，不会立即执行，而是放入微任务队列。

3. **同步代码继续执行**：
   ```javascript
   console.log(4);         // 同步执行，输出 4
   ```
   - 输出 `4`。

4. **微任务执行**：
   - 当前宏任务（同步代码）执行完毕后，开始执行微任务队列中的任务。
   - 执行 `.then` 回调，输出 `3`。

### 输出结果：
```
1
2
4
3
```

### 关键点说明：
1. **Promise 的 executor 函数是同步执行的**：
   - `console.log(1)`、`resolve('success')`、`console.log(2)` 都是同步执行的。

2. **`.then` 回调是异步的微任务**：
   - 即使 Promise 已经 `resolve`，`.then` 回调也不会立即执行，而是等待当前宏任务执行完毕后才会执行。

3. **事件循环的顺序**：
   - 同步代码（宏任务）→ 微任务（Promise 回调）→ 宏任务（如 `setTimeout`）。

### 扩展：如果加上 `setTimeout`
```javascript
console.log(4);
setTimeout(() => console.log(5));  // 宏任务
```

输出顺序会是：
```
1
2
4
3
5
```
因为 `setTimeout` 是宏任务，会在微任务（`3`）之后执行。


## EP03

这段代码展示了 **Promise 的执行顺序**，包括同步代码和异步代码的执行流程。让我们逐步解析：

### 代码执行过程：

1. **创建 Promise 对象**：
   ```javascript
   const promise = new Promise((resolve, reject) => {
     console.log(1);  // 同步执行，输出 1
     console.log(2);  // 同步执行，输出 2
   });
   ```
   - `new Promise` 的 **executor 函数是同步执行的**，所以会立即执行 `console.log(1)` 和 `console.log(2)`。
   - **但 Promise 没有被 `resolve` 或 `reject`**，所以它的状态仍然是 `pending`。

2. **注册 `.then` 回调**：
   ```javascript
   promise.then(() => {
     console.log(3);  // 微任务，但不会执行，因为 Promise 未 resolve/reject
   });
   ```
   - `.then` 的回调是**微任务**，但**只有当 Promise 被 `resolve` 或 `reject` 时才会执行**。
   - 由于 Promise 仍然是 `pending`，`console.log(3)` **不会执行**。

3. **同步代码继续执行**：
   ```javascript
   console.log(4);  // 同步执行，输出 4
   ```
   - 输出 `4`。

### 最终输出：
```
1
2
4
```

### 关键点说明：
1. **Promise 的 executor 函数是同步执行的**：
   - `console.log(1)` 和 `console.log(2)` 会立即执行。

2. **`.then` 回调只有在 Promise 状态改变时才会执行**：
   - 如果 Promise **没有 `resolve` 或 `reject`**，`.then` 回调不会触发。

3. **`console.log(3)` 不会执行**：
   - 因为 Promise 一直是 `pending`，没有进入微任务队列。

### 对比：如果 Promise 被 `resolve`
```javascript
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve();  // 状态变为 fulfilled
  console.log(2);
});
promise.then(() => {
  console.log(3);  // 微任务，会在同步代码执行完毕后执行
});
console.log(4);
```
**输出顺序**：
```
1
2
4
3
```
- 因为 `resolve()` 被调用，`.then` 回调会在同步代码执行完后执行。


## EP04
```ts
const fn = () => (new Promise((resolve, reject) => {
  console.log(1);
  resolve('success')
}))
fn().then(res => {
  console.log(res)
})
console.log('start')
```

这段代码展示了 **Promise 的执行顺序**，包括同步代码和异步代码的执行流程。让我们逐步解析：

### 代码执行过程：

1. **定义 `fn` 函数**：
   ```javascript
   const fn = () => (new Promise((resolve, reject) => {
     console.log(1);        // 同步执行，输出 1
     resolve('success');    // 同步执行，Promise 状态变为 fulfilled
   }));
   ```
   - `fn` 是一个函数，返回一个 `Promise`。
   - 当 `fn()` 被调用时，`new Promise` 的 **executor 函数会同步执行**，所以 `console.log(1)` 会立即执行。
   - `resolve('success')` 也会同步执行，Promise 状态变为 `fulfilled`。

2. **调用 `fn()` 并注册 `.then` 回调**：
   ```javascript
   fn().then(res => {
     console.log(res);      // 微任务，稍后执行
   });
   ```
   - `fn()` 返回一个已经 `resolve('success')` 的 Promise。
   - `.then` 的回调是**微任务**，不会立即执行，而是放入微任务队列。

3. **同步代码继续执行**：
   ```javascript
   console.log('start');    // 同步执行，输出 'start'
   ```
   - 输出 `'start'`。

4. **微任务执行**：
   - 当前宏任务（同步代码）执行完毕后，开始执行微任务队列中的任务。
   - 执行 `.then` 回调，输出 `'success'`（`res` 的值）。

### 最终输出：
```
1
start
success
```

### 关键点说明：
1. **`new Promise` 的 executor 函数是同步执行的**：
   - `console.log(1)` 和 `resolve('success')` 会立即执行。

2. **`.then` 回调是异步的微任务**：
   - 即使 Promise 已经 `resolve`，`.then` 回调也不会立即执行，而是等待当前宏任务执行完毕。

3. **事件循环的顺序**：
   - 同步代码（宏任务）→ 微任务（Promise 回调）→ 宏任务（如 `setTimeout`）。

### 扩展：如果加上 `setTimeout`
```javascript
console.log('start');
setTimeout(() => console.log('timeout'));  // 宏任务
```
输出顺序会是：
```
1
start
success
timeout
```
因为 `setTimeout` 是宏任务，会在微任务（`success`）之后执行。

## EP5

```ts
const promise = new Promise((resolve, reject) => {
  reject("error");
  resolve("success2");
});
promise
.then(res => {
    console.log("then1: ", res);
  }).then(res => {
    console.log("then2: ", res);
  }).catch(err => {
    console.log("catch: ", err);
  }).then(res => {
    console.log("then3: ", res);
  })
```

这段代码展示了 **Promise 链式调用** 的执行流程，特别是 `reject` 和 `catch` 的处理逻辑。让我们逐步解析：

### 代码执行过程：

1. **创建 Promise 并立即 `reject`**：
   ```javascript
   const promise = new Promise((resolve, reject) => {
     reject("error");      // Promise 状态变为 rejected
     resolve("success2");  // 无效，因为 Promise 状态已经锁定
   });
   ```
   - `reject("error")` 会立即将 Promise 状态设为 `rejected`，并携带错误信息 `"error"`。
   - `resolve("success2")` **不会生效**，因为 Promise 的状态一旦改变（`rejected` 或 `fulfilled`），就不能再改变。

2. **链式调用 `.then` 和 `.catch`**：
   ```javascript
   promise
     .then(res => {
       console.log("then1: ", res);  // 跳过，因为 Promise 已 rejected
     })
     .then(res => {
       console.log("then2: ", res);  // 跳过
     })
     .catch(err => {
       console.log("catch: ", err);  // 捕获错误，输出 "catch: error"
     })
     .then(res => {
       console.log("then3: ", res);  // 执行，输出 "then3: undefined"
     });
   ```

### 执行流程解析：
1. **`reject("error")`**：
   - Promise 直接进入 `rejected` 状态，后续的 `resolve("success2")` 被忽略。

2. **第一个 `.then`**：
   - 由于 Promise 是 `rejected`，第一个 `.then` 的回调（`then1`）**不会执行**，直接跳到后续的 `.catch`。

3. **第二个 `.then`**：
   - 由于前一个 `.then` 被跳过，第二个 `.then`（`then2`）**也不会执行**。

4. **`.catch`**：
   - 捕获到 `reject("error")` 的错误，输出 `"catch: error"`。
   - `.catch` 返回一个新的 Promise，默认是 `fulfilled` 状态（除非 `.catch` 内部抛出错误）。

5. **最后一个 `.then`（`then3`）**：
   - 由于 `.catch` 没有显式返回任何值，`res` 是 `undefined`，所以输出 `"then3: undefined"`。

### 最终输出：
```
catch: error
then3: undefined
```

### 关键点总结：
1. **Promise 状态一旦改变（`rejected`/`fulfilled`），就不能再改变**。
   - `reject("error")` 后，`resolve("success2")` 无效。

2. **`.then` 只有在 Promise 是 `fulfilled` 时才会执行**：
   - 如果 Promise 是 `rejected`，`.then` 会被跳过，直接进入 `.catch`。

3. **`.catch` 会捕获之前的错误，并返回一个新的 `fulfilled` Promise**：
   - 除非 `.catch` 内部再次抛出错误，否则后续的 `.then` 会正常执行。

4. **如果 `.then` 或 `.catch` 没有返回值，`res` 会是 `undefined`**：
   - 最后一个 `then3` 的 `res` 是 `undefined`，因为 `.catch` 没有返回任何值。

### 扩展：如果 `.catch` 返回一个值
```javascript
.catch(err => {
  console.log("catch: ", err);
  return "recovered";  // 返回一个值
})
.then(res => {
  console.log("then3: ", res);  // 输出 "then3: recovered"
})
```
**输出**：
```
catch: error
then3: recovered
```
- 因为 `.catch` 返回了 `"recovered"`，所以 `then3` 的 `res` 是这个值。
