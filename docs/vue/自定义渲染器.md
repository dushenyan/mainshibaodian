---
tags: [ '自定义渲染器 createRenderer()','__VUE_OPTIONS_API__','__VUE_PROD_DEVTOOLS__','__VUE_PROD_HYDRATION_MISMATCH_DETAILS__']
---

# 自定义渲染器

## Vue 自定义渲染器 createRenderer() 详解

### 一、什么是自定义渲染器

Vue 3 的核心特性之一就是其渲染系统与核心运行时解耦，这让我们可以通过 `createRenderer()` API 创建自定义的渲染器。这个功能允许开发者针对不同平台（如 Canvas、WebGL、Native 等）定制自己的渲染逻辑。

### 二、createRenderer() 基本结构

`createRenderer()` 接收一个包含平台特定节点操作方法的配置对象，返回一个包含 `render()` 和 `createApp()` 方法的渲染器实例。

```javascript
import { createRenderer } from 'vue'

const { render, createApp } = createRenderer({
  // 平台特定的API
  createElement,
  patchProp,
  insert,
  remove,
  createText,
  setText,
  createComment,
  setElementText,
  parentNode,
  nextSibling,
  // ...其他方法
})
```

### 三、关键 API 属性详解

#### 1. 节点操作方法

###### createElement
创建 DOM 元素或平台特定节点

```typescript
function createElement(type: string) {
  return document.createElement(type)
}
```

###### insert
插入节点到父节点中

```typescript
function insert(child, parent, anchor = null) {
  parent.insertBefore(child, anchor || null)
}
```

###### remove
移除子节点

```typescript
function remove(child) {
  const parent = child.parentNode
  if (parent) {
    parent.removeChild(child)
  }
}
```

#### 2. 属性处理方法

###### patchProp
处理元素属性/特性的更新

```typescript
function patchProp(el, key, prevValue, nextValue) {
  if (key.startsWith('on')) {
    // 处理事件
    const event = key.slice(2).toLowerCase()
    if (prevValue) el.removeEventListener(event, prevValue)
    if (nextValue) el.addEventListener(event, nextValue)
  } else {
    // 处理普通属性
    if (nextValue == null) {
      el.removeAttribute(key)
    } else {
      el.setAttribute(key, nextValue)
    }
  }
}
```

#### 3. 文本处理方法

###### createText
创建文本节点

```typescript
function createText(text) {
  return document.createTextNode(text)
}
```

###### setText
设置文本内容

```typescript
function setText(node, text) {
  node.nodeValue = text
}
```

###### createComment
创建注释节点

```typescript
function createComment(text) {
  return document.createComment(text)
}
```

###### setElementText
设置元素的文本内容

```typescript
function setElementText(el, text) {
  el.textContent = text
}
```

###### parentNode
获取节点的父节点

```typescript
function parentNode(node) {
  return node.parentNode
}
```

###### nextSibling
获取节点的下一个兄弟节点

```typescript
function nextSibling(node) {
  return node.nextSibling
}
```

### 四、完整示例代码

下面是一个完整的自定义渲染器示例，使用 Vite 打包后可直接在 HTML 中使用：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vue Custom Renderer</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  </head>
  <body>
    <div id="app"></div>

    <script>
      const { createRenderer, h } = Vue;

      // 创建自定义渲染器
      const { createApp } = createRenderer({
        createElement(type) {
          console.log("创建元素:", type);
          return document.createElement(type);
        },
        patchProp(el, key, prevValue, nextValue) {
          console.log("更新属性:", key, prevValue, "=>", nextValue);
          if (key.startsWith("on")) {
            const event = key.slice(2).toLowerCase();
            if (prevValue) el.removeEventListener(event, prevValue);
            if (nextValue) el.addEventListener(event, nextValue);
          } else {
            if (nextValue == null) {
              el.removeAttribute(key);
            } else {
              el.setAttribute(key, nextValue);
            }
          }
        },
        insert(child, parent, anchor = null) {
          console.log("插入节点:", child, "到", parent);
          if (parent && typeof parent.insertBefore === "function") {
            parent.insertBefore(child, anchor || null);
          }
        },
        remove(child) {
          console.log("移除节点:", child);
          const parent = child.parentNode;
          if (parent) {
            parent.removeChild(child);
          }
        },
        createText(text) {
          console.log("创建文本:", text);
          return document.createTextNode(text);
        },
        setText(node, text) {
          console.log("设置文本:", text);
          node.nodeValue = text;
        },
        createComment(text) {
          console.log("创建注释:", text);
          return document.createComment(text);
        },
        setElementText(el, text) {
          console.log("设置元素文本:", text);
          el.textContent = text;
        },
        parentNode(node) {
          return node.parentNode;
        },
        nextSibling(node) {
          return node.nextSibling;
        },
      });

      // 创建Vue应用
      const app = createApp({
        data() {
          return {
            count: 0,
            show: true,
          };
        },
        methods: {
          increment() {
            this.count++;
          },
          toggle() {
            this.show = !this.show;
          },
        },
        render() {
          return h("div", [
            h("h1", "自定义渲染器示例"),
            h("p", `计数: ${this.count}`),
            h("button", { onClick: this.increment }, "增加"),
            h("button", { onClick: this.toggle }, "切换"),
            this.show ? h("p", "显示的内容") : null,
          ]);
        },
      });

      app.mount(document.body);
    </script>
  </body>
</html>
```

### 五、使用场景与总结

#### 1. 常见使用场景

- 渲染到非 DOM 环境（如 Canvas、WebGL）
- 服务端渲染（SSR）定制
- 原生应用渲染（如 Weex、React Native）
- 创建特定领域的 DSL（领域特定语言）

#### 2. 通俗易懂的总结

可以把 Vue 的渲染器想象成一个"翻译官"：Vue 组件描述的是"我想要什么"，而渲染器负责把这些描述"翻译"成具体平台能理解的操作。`createRenderer()` 就是让我们自己来定义这个"翻译规则"。

默认情况下，Vue 提供了一个针对 DOM 的"翻译官"，但通过自定义渲染器，我们可以：

1. 让 Vue 组件渲染到 Canvas 上（变成图形而非 DOM）
2. 让 Vue 组件生成 PDF 文档
3. 让 Vue 组件控制终端命令行界面
4. 甚至可以用 Vue 的语法来控制硬件设备

核心思想是：Vue 负责管理组件的状态和逻辑，而渲染器负责把这些状态和逻辑"绘制"到目标平台上。这种解耦让 Vue 变得极其灵活，可以适应各种渲染目标。

### 六、Vite 打包后直接使用示例

使用 Vite 创建一个 Vue 自定义渲染器项目：

1. 创建项目：
```bash
pnpm create vite@latest vue-custom-renderer --template vue
cd vue-custom-renderer
pnpm install
```

2. 自定义渲染器
```ts
// src/custom-renderer.ts
import { createRenderer, h } from 'vue'

const { createApp } = createRenderer({
  createElement(type: string) {
    console.log('创建元素:', type)
    return document.createElement(type)
  },
  patchProp(el, key, prevValue, nextValue) {
    console.log('更新属性:', key, prevValue, '=>', nextValue)
    if (key.startsWith('on')) {
      const event = key.slice(2).toLowerCase()
      if (prevValue) el.removeEventListener(event, prevValue)
      if (nextValue) el.addEventListener(event, nextValue)
    } else {
      if (nextValue == null) {
        el.removeAttribute(key)
      } else {
        el.setAttribute(key, nextValue)
      }
    }
  },
  insert(child: Node, parent: HTMLElement, anchor = null) {
    console.log('插入节点:', child, '到', parent)
    if (parent && typeof parent.insertBefore === 'function') {
      parent.insertBefore(child, anchor || null)
    }
  },
  remove(child: Node) {
    console.log('移除节点:', child)
    const parent = child.parentNode
    if (parent) {
      parent.removeChild(child)
    }
  },
  createText(text) {
    console.log('创建文本:', text)
    return document.createTextNode(text)
  },
  setText(node, text) {
    console.log('设置文本:', text)
    node.nodeValue = text
  },
  createComment(text) {
    console.log('创建注释:', text)
    return document.createComment(text)
  },
  setElementText(el, text) {
    console.log('设置元素文本:', text)
    el.textContent = text
  },
  parentNode(node) {
    return node.parentNode as HTMLElement
  },
  nextSibling(node) {
    return node.nextSibling
  },
})

export default createApp
```

3. 修改 `src/main.ts`：

```typescript
import createApp from './custom-renderer'
import { createRenderer, h } from 'vue'

const app = createApp({
  data() {
    return {
      count: 0,
      show: true
    }
  },
  methods: {
    increment() {
      this.count++
    },
    toggle() {
      this.show = !this.show
    }
  },
  render() {
    return h('div', [
      h('h1', 'Vite + 自定义渲染器'),
      h('p', `计数: ${this.count}`),
      h('button', { onClick: this.increment }, '增加'),
      h('button', { onClick: this.toggle }, '切换'),
      this.show ? h('p', '显示的内容') : null
    ])
  }
})

// 挂载应用 mount需要挂载DOM元素
app.mount(document.getElementById('app')!)
```

3. 运行项目：
```bash
pnpm run dev
```

4. 构建生产版本：
```bash
pnpm run build
```

构建后的文件可以在 `dist` 目录中找到，可以直接在 HTML 中使用。

## Vue 编译时标志 __VUE_OPTIONS_API__ 详解

### 一、什么是 __VUE_OPTIONS_API__

`__VUE_OPTIONS_API__` 是 Vue 3 中的一个编译时特性标志，用于控制是否支持 Options API（选项式 API）。这个标志主要影响打包时的 Tree Shaking（树摇）优化，可以帮助减小最终打包体积。

### 二、为什么需要这个标志

Vue 3 引入了 Composition API（组合式 API），但为了向后兼容，默认仍然包含 Options API 的支持。如果你的项目完全使用 Composition API，可以通过禁用 Options API 来减少打包体积。

#### 主要作用：
1. **减小打包体积**：移除未使用的 Options API 相关代码
2. **明确项目规范**：强制使用 Composition API
3. **优化性能**：减少不必要的代码加载

### 三、如何使用 __VUE_OPTIONS_API__

#### 1. 在 Vite 中配置

```javascript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vite.dev/config/
export default defineConfig({
  plugins: [vue()],
  define: {
    // 禁用 Options选项
    __VUE_OPTIONS_API__: false
  }
})
```

#### 2. 在 webpack 中配置

```javascript
// webpack.config.ts
module.exports = {
  // ...
  plugins: [
    new webpack.DefinePlugin({
      __VUE_OPTIONS_API__: 'false',
      // __VUE_PROD_DEVTOOLS__: 'false',
      // __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: 'false'
    })
  ]
}
```

### 四、代码示例对比

#### 1. 启用 Options API（默认）

```javascript
// 可以同时使用 Options API 和 Composition API
export default {
  data() {
    return {
      count: 0
    }
  },
  setup() {
    const doubled = computed(() => count.value * 2)
    return { doubled }
  }
}
```

#### 2. 禁用 Options API

```javascript
// 只能使用 Composition API
export default {
  setup() {
    const count = ref(0)
    const doubled = computed(() => count.value * 2)
    return { count, doubled }
  }
}

// 以下代码会报错
export default {
  data() { // 报错: Options API 已被禁用
    return {
      count: 0
    }
  }
}
```

### 五、完整可运行示例

下面是一个使用 Vite 打包后可直接在 HTML 中使用的示例：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vue __VUE_OPTIONS_API__ 示例</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body>
  <div id="app"></div>

  <script>
    // 模拟禁用 Options API 的环境
    const { createApp, ref, computed } = Vue
    
    // 正确的 Composition API 用法
    const ValidComponent = {
      setup() {
        const count = ref(0)
        const doubled = computed(() => count.value * 2)
        const increment = () => count.value++
        
        return {
          count,
          doubled,
          increment
        }
      },
      template: `
        <div>
          <h1>Composition API 示例</h1>
          <p>计数: {{ count }}</p>
          <p>双倍: {{ doubled }}</p>
          <button @click="increment">增加</button>
        </div>
      `
    }
    
    // 错误的 Options API 用法（在禁用环境下会报错）
    const InvalidComponent = {
      data() {
        return {
          count: 0
        }
      },
      computed: {
        doubled() {
          return this.count * 2
        }
      },
      methods: {
        increment() {
          this.count++
        }
      },
      template: `
        <div>
          <h1>Options API 示例</h1>
          <p>计数: {{ count }}</p>
          <p>双倍: {{ doubled }}</p>
          <button @click="increment">增加</button>
        </div>
      `
    }
    
    // 创建应用时可以选择使用哪个组件
    // 在真实禁用 Options API 的环境中，InvalidComponent 会导致编译错误
    createApp(ValidComponent).mount('#app')
    // createApp(InvalidComponent).mount('#app') // 这行在禁用 Options API 时会报错
  </script>
</body>
</html>
```

### 六、Vite 项目配置示例

1. 创建 Vite 项目：
```bash
pnpm create vite@latest vue-options-api-flag --template vue
code vue-options-api-flag
pnpm install
```

2. 修改 `vite.config.ts`：

```typescript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vite.dev/config/
export default defineConfig({
  plugins: [vue()],
  define: {
    // 禁用 Options选项
    __VUE_OPTIONS_API__: false
  }
})
```

3. 修改 `src/App.vue` 为 Composition API：

```html
<script setup>
import { ref, computed } from 'vue'

const count = ref(0)
const doubled = computed(() => count.value * 2)
const increment = () => count.value++
</script>

<template>
  <div>
    <h1>Composition API 示例</h1>
    <p>计数: {{ count }}</p>
    <p>双倍: {{ doubled }}</p>
    <button @click="increment">增加</button>
  </div>
</template>
```

4. 运行项目：
```bash
pnpm run dev
```

5. 尝试添加 Options API 代码会报错：

```html
<script>
export default {
  data() { // 这里会报错 界面没问题 但是浏览器控制台会报错
    return {
      count: 0
    }
  }
}
</script>
```

### 七、通俗易懂的总结

可以把 `__VUE_OPTIONS_API__` 想象成一个"开关"：

1. **开启状态（默认）**：Vue 就像一个会说两种语言（Options API 和 Composition API）的翻译，无论你用哪种方式写代码，它都能理解。

2. **关闭状态**：Vue 变成了一个只会说 Composition API 一种语言的翻译，如果你尝试用 Options API 跟它交流，它会直接告诉你"我听不懂"。

**为什么要关闭 Options API？**

- **更小的包体积**：就像旅行时只带必要的行李，不带用不上的东西
- **更一致的代码风格**：团队所有人都用同一种方式写代码
- **更好的性能**：减少不必要的代码加载和执行

**适用场景**：
- 新项目，从一开始就决定只用 Composition API
- 老项目已经完成从 Options API 到 Composition API 的迁移
- 对包体积有严格要求的项目

**注意事项**：
- 如果项目中有第三方组件库仍在使用 Options API，不要禁用此标志
- 迁移老项目时要确保所有代码都已转换为 Composition API
- 

## Vue 编译时标志 __VUE_PROD_DEVTOOLS__ 详解

### 一、Vue Devtools 简介

Vue Devtools 是 Vue 官方提供的浏览器开发者工具扩展，用于调试 Vue 应用程序。它允许开发者检查组件层次结构、状态、事件等。

### 二、__VUE_PROD_DEVTOOLS__ 的作用

`__VUE_PROD_DEVTOOLS__` 是一个编译时标志，用于控制生产环境下是否启用 Vue Devtools 支持。

- **默认值**：`false`（生产环境禁用 Devtools）
- **设置为 true**：生产环境启用 Devtools

### 三、为什么需要这个标志

#### 生产环境下的考量
1. **安全性**：防止暴露应用内部结构和状态
2. **性能**：减少不必要的代码注入
3. **调试需求**：某些生产环境也需要调试能力

### 四、如何使用

#### 1. 在 Vite 中配置

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  define: {
    // 生产环境禁用 Devtools
    __VUE_PROD_DEVTOOLS__: false
  }
})
```

#### 2. 在 webpack 中配置

```typescript
// webpack.config.js
module.exports = {
  // ...
  plugins: [
    new VueLoaderPlugin({
      compilerOptions: {
        __VUE_PROD_DEVTOOLS__: true
      }
    })
  ]
}
```

### 五、代码示例对比

#### 1. 默认情况（__VUE_PROD_DEVTOOLS__: false）

```typescript
// 生产环境下无法使用 Devtools
const app = createApp(App)
app.mount('#app')
```

### 六、Vite 项目配置示例

1. 创建 Vite 项目：
```bash
pnpm create vite@latest vue-prod-devtools --template vue
code vue-prod-devtools
pnpm install
```

2. 修改 `vite.config.ts`：

```typescript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  define: {
    __VUE_PROD_DEVTOOLS__: true
  },
  plugins: [
    vue()
  ]
})
```

3. 修改 `src/main.ts`：

```typescript
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)

app.mount('#app')
```

4. 修改 `src/App.vue`：

```html
<script setup>
import { ref } from 'vue'

const count = ref(0)
const increment = () => count.value++
</script>

<template>
  <div>
    <h1>Vue Devtools 生产环境示例</h1>
    <p>计数: {{ count }}</p>
    <button @click="increment">增加</button>
  </div>
</template>
```

5. 运行项目：
```bash
pnpm run dev
```

6. 构建**生产版本**：
```bash
pnpm run build
```

### 七、通俗易懂的总结

可以把 Vue Devtools 想象成汽车的"诊断接口"：

1. **开发环境**：默认开启，就像4S店里的诊断电脑可以随意连接
2. **生产环境**：默认关闭，就像卖给消费者的汽车不开放诊断接口

`__VUE_PROD_DEVTOOLS__` 就是决定是否在生产车上保留诊断接口的开关：

- **关闭（默认）**：更安全，更轻量，但出问题时难以诊断
- **开启**：方便调试，但可能暴露内部信息，略微增加包体积

**什么时候开启？**
- 预发布环境需要调试时
- 客户支持需要检查生产环境问题时
- 内部工具不担心暴露实现细节时

**注意事项：**
- 不要在生产环境长期开启
- 敏感应用（如金融、医疗）应该保持关闭
- 开启后会略微增加打包体积（约2-5KB）

**最佳实践：**
```javascript
// 可以根据环境变量动态配置
__VUE_PROD_DEVTOOLS__ = import.meta.env.DEV || import.meta.env.VITE_DEBUG === 'true'
```

## Vue 编译时标志 __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ 详解

### 一、什么是 hydration 不匹配

在 Vue 的 SSR（服务端渲染）场景中，"hydration"（水合）是指将服务器渲染的静态 HTML 转换为客户端交互式应用程序的过程。当服务端和客户端渲染结果不一致时，就会发生 hydration 不匹配。

### 二、__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ 的作用

`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__` 是一个编译时标志，用于控制生产环境下 hydration 不匹配时的错误信息详细程度。

- **默认值**：`false`（生产环境只显示简要错误）
- **设置为 true**：生产环境也会显示详细的 hydration 不匹配信息

### 三、为什么需要这个标志

#### 生产环境下的权衡
1. **安全性**：详细的错误信息可能暴露应用内部结构
2. **调试需求**：生产环境有时也需要诊断 hydration 问题
3. **包体积**：详细的错误信息会增加最终包大小

### 四、如何使用

#### 1. 在 Vite 中配置

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  define: {
    // 开启 hydration 不匹配详细信息
    __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: true
  },
  plugins: [
    vue()
  ]
})
```

#### 2. 在 webpack 中配置

```typescript
// webpack.config.ts
module.exports = {
  // ...
  plugins: [
    new VueLoaderPlugin({
      compilerOptions: {
        __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: true
      }
    })
  ]
}
```

### 五、代码示例对比

#### 1. 不匹配场景示例

```html
<!-- 服务端渲染的HTML -->
<div id="app">
  <div class="server-count">10</div>
</div>

<!-- 客户端渲染的Vue组件 -->
<script>
export default {
  data() {
    return {
      count: Math.random() > 0.5 ? 10 : 20 // 随机值会导致不匹配
    }
  }
}
</script>

<template>
  <div id="app">
    <div class="client-count">{{ count }}</div>
  </div>
</template>
```

#### 2. 不同配置下的错误信息

**__VUE_PROD_HYDRATION_MISMATCH_DETAILS__: false**
```
[Hydration] Mismatch detected
```

**__VUE_PROD_HYDRATION_MISMATCH_DETAILS__: true**
```
[Hydration] Mismatch detected in <div class="client-count">
- Server rendered: "10"
- Client rendered: "20"
```

### 六、完整可运行示例

下面是一个模拟 hydration 不匹配的示例，使用 Vite 打包后可直接在 HTML 中使用：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vue Hydration Mismatch 示例</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body>
  <!-- 模拟服务端渲染的HTML -->
  <div id="app">
    <div class="server-rendered">服务端渲染内容</div>
    <div class="count">10</div>
  </div>

  <script>
    const { createApp, ref } = Vue
    
    // 模拟客户端渲染
    createApp({
      setup() {
        // 故意制造不匹配
        const count = ref(Math.random() > 0.5 ? 10 : 20)
        
        return { count }
      },
      template: `
        <div id="app">
          <div class="client-rendered">客户端渲染内容</div>
          <div class="count">{{ count }}</div>
        </div>
      `
    }).mount('#app')
  </script>
</body>
</html>
```

### 七、Vite 项目配置示例

1. 创建 Vite SSR 项目：
```bash
npm create vite@latest vue-hydration-mismatch --template vue
code vue-hydration-mismatch
pnpm install
pnpm install @vitejs/plugin-vue @vue/server-renderer --save-dev
```

2. 修改 `vite.config.ts`：

```typescript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { createRequire } from 'module'
const require = createRequire(import.meta.url)

export default defineConfig({
  define: {
    // 开启 hydration 不匹配详细信息
    __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: true
  },
  plugins: [
    vue()
  ],
  ssr: {
    noExternal: ['vue']
  }
})
```

3. 创建 SSR 入口文件 `src/entry-server.js`：

```javascript
import { createSSRApp } from 'vue'
import { renderToString } from '@vue/server-renderer'
import App from './App.vue'

export async function render() {
  const app = createSSRApp(App)
  const html = await renderToString(app)
  return { html }
}
```

4. 修改 `src/App.vue` 制造不匹配：

```html
<script setup>
import { ref } from 'vue'

// 服务端和客户端会有不同的初始值
const count = ref(typeof window === 'undefined' ? 10 : Math.random() > 0.5 ? 10 : 20)
</script>

<template>
  <div>
    <h1>Hydration 不匹配示例</h1>
    <p>计数: {{ count }}</p>
  </div>
</template>
```

5. 创建 `server.js`：

```javascript
import express from 'express'
import { createServer } from 'vite'
import { fileURLToPath } from 'url'
import { dirname, join } from 'path'

const __dirname = dirname(fileURLToPath(import.meta.url))
const isProduction = process.env.NODE_ENV === 'production'

async function createViteServer() {
  const app = express()
  
  let vite
  if (!isProduction) {
    vite = await createServer({
      server: { middlewareMode: true },
      appType: 'custom'
    })
    app.use(vite.middlewares)
  } else {
    app.use(express.static(join(__dirname, 'dist/client')))
  }
  
  app.use('*', async (req, res) => {
    try {
      const { render } = await (isProduction
        ? import('./dist/server/entry-server.js')
        : vite.ssrLoadModule('/src/entry-server.js'))
      
      const { html } = await render()
      
      const template = `
        <!DOCTYPE html>
        <html>
          <head>
            <title>Vite SSR</title>
          </head>
          <body>
            <div id="app">${html}</div>
            <script type="module" src="/src/entry-client.js"></script>
          </body>
        </html>
      `
      
      res.status(200).set({ 'Content-Type': 'text/html' }).end(template)
    } catch (e) {
      console.error(e)
      res.status(500).end(e.message)
    }
  })
  
  return app
}

createViteServer().then(app => {
  app.listen(3000, () => {
    console.log('http://localhost:3000')
  })
})
```

6. 运行项目：
```bash
npm run dev
```

### 八、通俗易懂的总结

可以把 hydration 过程想象成"复活"一个木乃伊：

1. **服务端渲染**：先制作一个"木乃伊"（静态HTML）
2. **客户端 hydration**：给木乃伊"注入生命"（添加交互性）

`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__` 就像是决定在"复活"失败时：

- **关闭（默认）**：只说"复活失败了"，不告诉你具体哪里出了问题
- **开启**：详细告诉你"左手第3根手指长度不匹配，应该是5cm但现在是6cm"

**什么时候开启？**
- 生产环境需要调试 hydration 问题时
- 开发阶段诊断难以复现的不匹配问题
- 当 hydration 问题只在特定环境下出现时

**注意事项：**
- 生产环境通常应该关闭，除非有特殊调试需求
- 详细错误信息可能暴露应用内部结构
- 会增加最终打包体积（虽然影响很小）
